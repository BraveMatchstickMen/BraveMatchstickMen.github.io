<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="时空人" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="只要思想不滑坡 办法总比困难多">
<meta property="og:type" content="website">
<meta property="og:title" content="时空人">
<meta property="og:url" content="http://blog.chusaikeji.com/index.html">
<meta property="og:site_name" content="时空人">
<meta property="og:description" content="只要思想不滑坡 办法总比困难多">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="时空人">
<meta name="twitter:description" content="只要思想不滑坡 办法总比困难多">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"right","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 时空人 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">时空人</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-heartbeat fa-fw"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/30/《Clean-Code》/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-30T22:24:08+08:00" content="2018-04-30">
              2018-04-30
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.整洁代码</p>
<blockquote>
<p>让营地比你来时更干净.</p>
</blockquote>
<p>2.有意义的命名</p>
<p>总结一下何为好的命名:</p>
<p>(1).名副其实. 变量、函数或类的名称应该已经答复了所有的大问题. 它该告诉你, 它为什么会存在, 它做什么事, 该怎么用. 如果名称需要注释来补充, 那就不算名副其实.</p>
<p>(2).做有意义的区分. 比如有三个类Product &amp; ProductInfo &amp; ProductData, 你能区分出他们的意思吗!</p>
<p>(3).避免误导. 比如上面举到的viewHead和headView的例子. 再来个长一点的感受一下<br>XYZControllerForEfficientHandlingOfStrings 和 XYZControllerForEfficientStorageOfStrings 你分明白了吗?</p>
<p>(4).使用读的出来的名称. 这样你与同事沟通就不用说这个、那个了, 说半天也不知道是哪个.</p>
<p>对于命名, GoF的23种Design Pattern核心价值之一就是清晰的命名了23种常用模式，不信你可以试试看能不能想出更好地命名.</p>
<p>3.函数</p>
<p>4.注释</p>
<p>5.格式</p>
<p>6.对象和数据结构</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/30/《Cocoa-Design-Patterns》/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-30T22:24:08+08:00" content="2018-04-30">
              2018-04-30
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>没想好怎么写, 列个标题先</p>
<p>1.模型 - 视图 - 控制器</p>
<p>2.两阶段创建</p>
<p>3.模板方法</p>
<p>4.动态创建</p>
<p>5.通知</p>
<p>###三个类一个方法模拟iOS通知实现</p>
<h4 id="三个类"><a href="#三个类" class="headerlink" title="三个类:"></a>三个类:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  @brief  关于通知的信息类</span><br><span class="line"> */</span><br><span class="line">@interface MyNotification : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong, readwrite) NSString *name;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign, readwrite) id object;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong, readwrite) NSDictionary *infoDictionary;</span><br><span class="line"></span><br><span class="line">- (id)initWithName:(NSString *)name object:(id)anObject userInfo:(NSDictionary *)someUserInfo;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  @brief  存储关于注册的观察者的信息</span><br><span class="line"> */</span><br><span class="line">@interface MYNotificationObserverRecord : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign, readwrite) id object;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign, readwrite) id observer;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign, readwrite) SEL selector;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  @brief 单例模式 逻辑处理类</span><br><span class="line"> */</span><br><span class="line">@interface MYNotificationCenter : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary *observersDictionary;</span><br><span class="line"></span><br><span class="line">- (id)defaultCenter;</span><br><span class="line"></span><br><span class="line">- (void)addObserver:(id)notificationObserver selector:(SEL)notificationSelector name:(NSString *)notificationName object:(id)objectOfInterest;</span><br><span class="line"></span><br><span class="line">- (void)removeObserver:(id)notificationObserver;</span><br><span class="line"></span><br><span class="line">- (void)postNotification:(MyNotification *)aNotification;</span><br><span class="line"></span><br><span class="line">- (void)postNotification:(NSString *)aName object:(id)objectOfInterest userInfo:(NSDictionary *)someUserInfo;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>一个方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)performSelector:(SEL)aSelector withObject:(id)object;</span><br></pre></td></tr></table></figure></p>
<p>###注意几点:</p>
<p>1.记得remove!记得remove!记得remove!<br>2.在接收通知的方法里加一个判断<br><code>if (self.isViewLoaded &amp;&amp; self.view.window) {}</code><br>3.注意线程问题</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/30/SQLite封装/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-30T22:24:08+08:00" content="2018-04-30">
              2018-04-30
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><br></p>
<p>iOS中的数据存储方式主要有:</p>
<ul>
<li><p>Plist (NSArray/NSDictionary)</p>
</li>
<li><p>Preference(偏好设置/NSUserDefaults)</p>
</li>
<li><p>NSCoding (NSKeyedArchiver/NSkeyedUnarchiver)</p>
</li>
<li><p>SQLite3</p>
</li>
<li><p>Core Data</p>
</li>
</ul>
<p>共5种方式, 其中前三种可归纳为文件存储, 适用于简单少量数据存储, 不适用于大批量数据存储; 后两种为数据库存储, 可存储大量数据. 今天主要是对SQLite进行一个简单的封装.首先对SQLite进行简单的一个介绍:</p>
<p>SQLite是目前主流的轻量型嵌入式关系数据库. 它占用资源非常的低, 在嵌入式设备中, 可能只需要几百K的内存就够了, 它的处理速度比Mysql、PostgreSQL还快. 常见的适用于PC端的关系型数据库有Oracle、MySQL、SQL Server、DB2、Sybase, 而在嵌入式\移动客户端中, 我们主要使用的是SQLite. 下面直接上代码:<br><br><br>DataBaseHandler.h</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;
#import &lt;sqlite3.h&gt;


@interface DataBaseHandler : NSObject

{
    sqlite3 *dbPoint;
}


// 单例的创建方法
+ (DataBaseHandler *)shareInstance;


/**
 *  打开数据库
 *
 *  @param dbname 数据库名称
 *
 *  @text 哪个方法
 */
- (void)openDb:(NSString *)dbname text:(NSString *)text;


/**
 *  执行无返回值的sql
 *
 *  @param sql sql语句
 *
 *  @text 哪个方法
 */
- (void)executeNonReturnValue:(NSString *)sql text:(NSString *)text;


/**
 *  执行有返回值的sql
 *
 *  @param sql sql语句
 *
 *  @return 查询结果
 */
- (NSArray *)executeHaveReturnValue:(NSString *)sql;


/**
 *  判断数据库方法执行结果
 *
 *  @param result 调用数据库方法返回的结果
 *
 *  @text 哪个方法
 */
- (void)judgeResult:(int)result text:(NSString *)text;

@end
</code></pre><p>   <br></p>
<p>DataBaseHandler.m</p>
<pre><code>#import &quot;DataBaseHandler.h&quot;

@implementation DataBaseHandler


+ (DataBaseHandler *)shareInstance
{
    // 当第一次执行的时候会产生一个空指针
    static DataBaseHandler *dbHandler = nil;

    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        // 对指针进行判断, 当第一次执行的时候创建一个对象
        if (dbHandler == nil) {
            dbHandler = [[DataBaseHandler alloc] init];
        }
    });

    // 无论是创建的和已经存在的, 都在这里直接return除去
    return dbHandler;
}


- (void)openDb:(NSString *)dbname text:(NSString *)text
{
    NSString *docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];
    NSString *dbPath = [docPath stringByAppendingString:dbname];

    // 参数1: 数据库文件存储的路径
    // 参数2: 数据库dbPoint指针地址
    // 返回值: 执行sqlite函数的结果(int类型)
    int result = sqlite3_open([dbPath UTF8String], &amp;dbPoint);

    // 利用封装的方法判断结果
    [self judgeResult:result text:text];
}



- (void)executeNonReturnValue:(NSString *)sql text:(NSString *)text
{
    int result = sqlite3_exec(dbPoint, [sql UTF8String], NULL, NULL, NULL);
    [self judgeResult:result text:text];
}



- (NSArray *)executeHaveReturnValue:(NSString *)sql
{
    // 创建一个可变数组, 用于存储数据
    NSMutableArray *rows=[NSMutableArray array];

    // 创建一个数据库的替身, 存储对数据库的所有操作
    sqlite3_stmt *stmt = nil;

    /**
     *  让数据库执行sql语句, 并把结果保存到stmt中
     *
     *  @param dbPoint     数据库指针
     *  @param UTF8String] sql语句
     *  @param -1          限制sql语句的长度(如果是-1, 就是不限制)
     *  @param stmt        替身指针的地址
     *  @param NULL        空
     *
     */
    int result = sqlite3_prepare_v2(dbPoint, [sql UTF8String], -1, &amp;stmt, NULL);

    // 判断是否正确
    if (SQLITE_OK == result) {

        // 当sql执行成功, 遍历数据
        // 循环遍历所有的结果, 每次遍历到一条数据, 都会返回sqlite_row, 如果没有数据了, 就不会返回SQLITE_ROW, 跳出循环
        while (SQLITE_ROW == sqlite3_step(stmt)) {

            // 取int类型的数据
            int columnCount = sqlite3_column_count(stmt);

            // 创建一个可变字典, 用来存储数据
            NSMutableDictionary *dic=[NSMutableDictionary dictionary];

            for (int i = 0; i &lt; columnCount; i++) {

                // 在循环体中去按列取数据
                // 取得列名
                const char *name = sqlite3_column_name(stmt, i);

                // 取得某列的值
                const unsigned char *value = sqlite3_column_text(stmt, i);

                // 将char *字符串转为NSString字符串
                dic [[NSString stringWithUTF8String:name]] = [NSString stringWithUTF8String:(const char *) value];
            }

            [rows addObject:dic];
        }
    }

    // 销毁stmt替身, 把里面的操作和结果写入本地sqlite文件
    sqlite3_finalize(stmt);

    return rows;

}



- (void)judgeResult:(int)result text:(NSString *)text
{
    if (result == SQLITE_OK) {
        NSLog(@&quot;%@成功&quot;, text);
    } else {
        NSLog(@&quot;错误代码: %d&quot;, result);
        NSLog(@&quot;%@失败&quot;,text);
    }
}

@end
</code></pre><p><br></p>
<p>以上就是我们对SQLite的一个简单封装. 在实际开发当中, 我们还会经常用到iOS平台的SQLite数据库框架FMDB, FMDB以OC的方式封装了SQLite的C语言API, 大家可以googol一下, 或者参考一下<a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">git地址</a>, 或者参考此文章<a href="http://article.yeeyan.org/compare/307572" target="_blank" rel="noopener">FMDB的用法</a>.</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/30/Simple-Custom-ScrollView/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-30T22:24:08+08:00" content="2018-04-30">
              2018-04-30
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.jianshu.com/p/7631a5b1dec5" target="_blank" rel="noopener">上一篇文章</a>对UIScrollView的原理、属性和方法做了比较详细的理解, 本文旨在通过<em>自定义</em>, 来实现一个简单的scrollView, 再次加深对其理解. </p>
<p>在SimpleCustomScrollView.h</p>
<pre><code>#import &lt;UIKit/UIKit.h&gt;

@interface SimpleCustomScrollView : UIView

// 咱们也定义一个跟系统一样的contentSize, 实现滚动的范围
@property (nonatomic) CGSize contentSize;

@end
</code></pre><p>在SimpleCustomScrollView.m</p>
<pre><code>#import &quot;SimpleCustomScrollView.h&quot;

@implementation SimpleCustomScrollView


- (instancetype)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame:frame];
    if (self) {

        // 给视图添加pan手势
        UIPanGestureRecognizer *gestureRecognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(handlePanGesture:)];
        [self addGestureRecognizer:gestureRecognizer];
    }
    return self;
}



- (void)handlePanGesture:(UIPanGestureRecognizer *)gestureRecognizer
{
    // translationInView 这个方法返回的是:在指定父视图坐标系统中, 横、纵坐标移动的坐标
    CGPoint translation = [gestureRecognizer translationInView:self];
    CGRect bounds = self.bounds;

    // 动态改变bounds
    CGFloat newBoundsOriginX = bounds.origin.x - translation.x;
    CGFloat minBoundsOriginX = 0.0;
    CGFloat maxBoundsOriginX = self.contentSize.width - bounds.size.width;
    bounds.origin.x = fmax(minBoundsOriginX, fmin(newBoundsOriginX, maxBoundsOriginX));

    CGFloat newBoundsOriginY = bounds.origin.y - translation.y;
    CGFloat minBoundsOriginY = 0.0;
    CGFloat maxBoundsOriginY = self.contentSize.height - bounds.size.height;
    bounds.origin.y = fmax(minBoundsOriginY, fmin(newBoundsOriginY, maxBoundsOriginY));

    self.bounds = bounds;

    // 因为拖动起来一直是在递增, 所以每次都要用 setTranslation: 方法置0
    [gestureRecognizer setTranslation:CGPointZero inView:self];

    // 真相只有一个, 打印一下
    NSLog(@&quot;self.view&apos;s bounds is : %@&quot;, NSStringFromCGRect(self.bounds));
}

@end
</code></pre><p>ok. 到这, 咱们自定义的一个简单scrollView就完成了, 在viewController中测试一下</p>
<p>在ViewController.m中</p>
<pre><code>#import &quot;ViewController.h&quot;
#import &quot;SimpleCustomScrollView.h&quot;

@interface ViewController ()

@property (nonatomic, strong) SimpleCustomScrollView *customScroll;

@end

@implementation ViewController


- (void)viewDidLoad
{
    [super viewDidLoad];

    self.view.backgroundColor = [UIColor whiteColor];

    self.customScroll = [[SimpleCustomScrollView alloc] initWithFrame:self.view.bounds];
    [self.view addSubview:self.customScroll];

    // 跟系统的一样, 在这我们也必须要设置contentSize的大小, 否则无法滚动
    self.customScroll.contentSize = CGSizeMake(0, 800);

    [self p_setupSubviews];

}


// 创建视图
- (void)p_setupSubviews
{
    // 因为老喝橙汁么, 所以就报答一下橙色了
    UIView *orangeView = [[UIView alloc] initWithFrame:CGRectMake(100, 200, 200, 200)];
orangeView.backgroundColor = [UIColor orangeColor];

[self.customScroll addSubview:orangeView];
}

@end
</code></pre><p>运行一下, 是不是跟系统的一样可以滚动. ☀️ 最后附上<a href="https://github.com/BraveMatchstickMen/SimpleCustomScrollView" target="_blank" rel="noopener">git地址</a></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/30/UITableView-Tips/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-30T22:24:08+08:00" content="2018-04-30">
              2018-04-30
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>UITabelView是iOS开发中最常用, 也是最灵活的控件, 所以, 如何打造出更符合用户体验的tableView, 是我们不断去思考的一个问题. 本文不去详细讲述tableView的基本属性和方法, 而是从tableView各种不同的用法和效果, 侧面阐述tableView.</p>

<hr>
<p>####1. 解决UITableView分割线距左边有距离的问题</p>
<p><br></p>
<p>我们在使用tableview时会发现分割线的左边会短一些，通常可以使用setSeparatorInset:UIEdgeInsetsZero 来解决。但是升级到XCode6之后，在iOS8里发现没有效果。下面给出解决办法：</p>
<p>首先在viewDidLoad方法中加上如下代码：</p>
<pre><code>if ([self.tableView respondsToSelector:@selector(setSeparatorInset:)]) {

[self.tableView setSeparatorInset:UIEdgeInsetsZero];

}

if ([self.tableView     respondsToSelector:@selector(setLayoutMargins:)]) {

[self.tableView setLayoutMargins:UIEdgeInsetsZero];

}
</code></pre><p>然后在willDisplayCell方法中加入如下代码：</p>
<pre><code>- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath

{

if ([cell respondsToSelector:@selector(setSeparatorInset:)]) {

[cell setSeparatorInset:UIEdgeInsetsZero];

}

if ([cell respondsToSelector:@selector(setLayoutMargins:)]) {

[cell setLayoutMargins:UIEdgeInsetsZero];

}

}
</code></pre><p>此方法来自<a href="http://www.wl566.com/wz/156547.html" target="_blank" rel="noopener">文章</a></p>
<hr>
<p>####2. 点击cell上的Button获取cell的位置 (三种方法: tag, superView, block, 根据需求各自使用)</p>
<p><br></p>
<ul>
<li><p>方法一: 利用superView获取</p>
<pre><code>// 自定义cell: TestCell
TestCell *cell = [(TestCell *)[button superview] superview];
NSIndexPath *indexPath = [self.tableView indexPathForCell:cell];
NSLog(@&quot;indexPath is = %li&quot;,(long)indexPath.row);
</code></pre></li>
<li><p>方法二: 通过Block来获取</p>
</li>
</ul>
<p>在自定义cell的.h文件</p>
<pre><code>#import &lt;UIKit/UIKit.h&gt;

typedef void(^BlockButton)(UIButton *button);


@interface TestCell : UITableViewCell


@property (nonatomic, strong) UIButton *button;

@property (nonatomic, copy) BlockButton buttonBlock;

- (void)handlerButtonAction:(BlockButton)block;


@end
</code></pre><p>   在自定义cell的.m文件</p>
<pre><code>#import &quot;TestCell.h&quot;

@implementation TestCell


- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier
{
    self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];
    if (self) {
    [self p_setupSubviews];
    }
    return self;
}



- (void)p_setupSubviews
{
    self.button = [UIButton buttonWithType:UIButtonTypeSystem];
    self.button.frame = CGRectMake(self.frame.size.width-150, 10, 100, self.frame.size.height - 20);
    self.button.backgroundColor = [UIColor cyanColor];
    [self.button addTarget:self action:@selector(buttonAction:) forControlEvents:UIControlEventTouchUpInside];
    [self.contentView addSubview:self.button];
}



- (void)buttonAction:(UIButton *)button
{
    if (self.buttonBlock) {
        self.buttonBlock(button);
    }
}



- (void)handlerButtonAction:(BlockButton)block
{
    self.buttonBlock = block;
}

@end
</code></pre><p>在ViewController.m中</p>
<pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static NSString *str = @&quot;test&quot;;
    TestCell *cell = [tableView dequeueReusableCellWithIdentifier:str];
    if (!cell) {
        cell = [[TestCell alloc] initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:str];
    }

    [cell.button setTitle:[NSString stringWithFormat:@&quot;%ld&quot;, (long)indexPath.row] forState:UIControlStateNormal];

    [cell handlerButtonAction:^(UIButton *button) {
        NSLog(@&quot;=======   %ld&quot;, (long)indexPath.row);
        [cell.button setTitle:@&quot;OK!&quot; forState:UIControlStateNormal];

    }];
    return cell;
}
</code></pre><hr>
<p>####3. 改变点击cell时cell的颜色</p>
<pre><code>// 利用selectedBackgroundView方法
UIView *aView = [[UIView alloc] initWithFrame:cell.contentView.frame];
aView.backgroundColor = [UIColor colorWithRed:155/255.0 green:34/255.0 blue:63/255.0 alpha:1.0];
cell.selectedBackgroundView = aView;
</code></pre><hr>
<p>####4. cell的自适应</p>
<pre><code>// cell的高度问题, 都在这个方法中写
- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath
{

    // 1. 取数据

    NSString *name = [self.arr objectAtIndex:indexPath.row];

    // 2. 通过字符串的内容, 计算在一定宽度下, 文本占用的高度;

    NSDictionary *dic = @{NSFontAttributeName: [UIFont systemFontOfSize:17]};

    // 参数1: 通过CGSize给定一个宽度, 用来计算
    // 参数2: 通过以一个行为矩形, 计算高度
    // 参数3: 字体大小
    CGRect rect = [name boundingRectWithSize:CGSizeMake(tableView.frame.size.width, 10000) options:NSStringDrawingUsesLineFragmentOrigin attributes:dic context:nil];

    return rect.size.height;
}
</code></pre><hr>
<p>####5. 去除多余的cell</p>
<pre><code>// 去除tableView多余的cell
self.tableView.tableFooterView = [[UIView alloc] init];
</code></pre><hr>
<p>####6. 调整cell的间距</p>
<ul>
<li><p>在tableView样式为group时</p>
<pre><code>// 创建一个UITableViewCell的子类，重写setfrme方法

-(void)setFrame:(CGRect)frame
 {
     frame.origin.y -= 5;
     frame.size.height -= 10;
     [super setFrame:frame];
 }
</code></pre></li>
</ul>
<p><em>注意</em>: 上面的方法有待验证!</p>
<p>第二种方法是, 把cell的backgroundColor设置为灰色, 在cell上加一个白色的view, 让view的height比cell的height少一点(cell需要空出来的距离)就可以了. 但是自己感觉这个方法有点low啊, 大家要是有什么好方法, 还望不吝赐教哦.</p>
<p><br></p>
<p>####7. UITableView的section</p>
<ul>
<li>当tableview样式为plain时, section需要自己设定大小, 而且section默认是不会随着tableview滚动的.</li>
<li>当tableview样式为group时, section是自带的, section是跟随tableview滚动的</li>
</ul>
<p>####8. section 高度的问题</p>
<p>tableview 样式为 group 时, section 会有一个默认的高度. 如果你不想要这个高度, 在代理方法中 return 0, 你会发现并没有什么效果. 这是因为 iOS 系统会把 0 默认为无效设置, 所以你只要 return 一个接近于 0 的数就可以了, 这里我们 return CGFLOAT_MIN.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForHeaderInSection:(<span class="built_in">NSInteger</span>)section</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGFLOAT_MIN</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForFooterInSection:(<span class="built_in">NSInteger</span>)section</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGFLOAT_MIN</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你设置了上面的方法后, 充满期待的打开模拟器, 发现在 tableview 顶部还有一个大约 20 的 padding. 这是因为 iOS 7 的 View 默认是渗透到状态栏上面的, 所以需要再加一句</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.automaticallyAdjustsScrollViewInsets = <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure>
<hr>
<p>本文会持续更新…欢迎一起探讨完善此文章, 谢谢!</p>
<p>分享使人快乐, 分享使人进步, 转载请注明出处<br><a href="http://www.jianshu.com/p/a156806f6b58" target="_blank" rel="noopener">http://www.jianshu.com/p/a156806f6b58</a></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/30/项目目录结构/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-30T22:24:08+08:00" content="2018-04-30">
              2018-04-30
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天跟大家分享一下工程的项目结构,  闲话不多说, 直接上图:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/193863-a5832f1bf4c366c1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>从上图可以很直观的看出, 主目录是按照业务来划分的, 内目录是按照模块划分的. 下面逐个解释一下:</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><h3 id="Controller、View、Model"><a href="#Controller、View、Model" class="headerlink" title="Controller、View、Model"></a>Controller、View、Model</h3><p>按照典型的MVC模式划分, Controller对应的是所有模块的controller文件, View对应的是继承自view有关的文件, Model对应的是逻辑层的处理.</p>
<blockquote>
<p>说到项目架构, 现在流行的有MVC、MVVM、VIPER等. 很多同学一开始就在纠结到底用哪种, 这一下就给自己难住了, 没有必要, 对于新手而言, 就采用MVC, 更容易理解. 包括MVVM、VIPER其实都是MVC的演化版本</p>
</blockquote>
<p>从上图可以看出, 我们的MVC是按照tab来划分的, 蓦然项目中有两个tab, 一个是广场, 一个是我的, 再加上登录注册, 所以划分成这三部分.</p>
<blockquote>
<p>在划分model的时候有一个争议, 我们没有去建解析json的model层, 我们是直接解析后拿来用, 没有再去转为model对象. 这样做有利有弊, 希望能和大家探讨一下.</p>
</blockquote>
<h3 id="其他文件夹"><a href="#其他文件夹" class="headerlink" title="其他文件夹"></a>其他文件夹</h3><h4 id="Public"><a href="#Public" class="headerlink" title="Public"></a>Public</h4><p>这个目录放一些公用的类, 具体结构如下图:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/193863-35c8c73984e5fb13.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h5 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h5><p>放一些宏、或者公用的头文件等</p>
<h5 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h5><p>图片资源相关文件</p>
<h5 id="CacheData"><a href="#CacheData" class="headerlink" title="CacheData"></a>CacheData</h5><p>数据持久化相关文件</p>
<h5 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h5><p>网络层有关的文件</p>
<h4 id="Libary"><a href="#Libary" class="headerlink" title="Libary"></a>Libary</h4><p><img src="http://upload-images.jianshu.io/upload_images/193863-1728354e5b5b324a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这个目录存放的是一些第三方框架文件, 从图上可以看出, 项目中用到了6个三方框架. </p>
<blockquote>
<p>除了手动管理三方框架, 我们还可以用Cocoapods来自动导入第三方框架, 很方便, 但也有缺陷. </p>
</blockquote>
<h4 id="Frameworks"><a href="#Frameworks" class="headerlink" title="Frameworks"></a>Frameworks</h4><p>导入的一些框架文件</p>
<h4 id="APP"><a href="#APP" class="headerlink" title="APP"></a>APP</h4><p>AppDelegate.h 和 AppDelegate.m 文件</p>
<h2 id="拿到项目怎么办"><a href="#拿到项目怎么办" class="headerlink" title="拿到项目怎么办"></a>拿到项目怎么办</h2><p>拿到一个项目, 首要的是确定主体框架是什么, 在脑海里迅速形成根据主体框架来确定的目录结构, 然后以最快的速度把项目的框架搭建出来. 如果是团队协作的项目, 就可以根据目录结构去做各自负责的那一部分了.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有一个清晰明了的项目结构, 可以体现出我们的开发素质, 以及我们对整个项目的理解, 也是提高团队开发效率必不可少的. 相反的, 我们去一家公司, 怎么看刚接触的项目, 也是按照目录来看. 有一定经验后, 只看目录就可以对整个项目有一个整体的把握了.</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/30/高屋建瓴,-iOS地图开发/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-30T22:24:08+08:00" content="2018-04-30">
              2018-04-30
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 iOS 中, 地图开发经常会用到的三个框架, 一个是苹果系统自带的 MapKit 框架, 另外两个, 一个是百度地图 BMKMapView, 另一个是高德地图 MAMapView. 当时我莫名的对一个问题产生了浓厚的兴趣, 就是百度地图和高德地图英文命名是什么意思!? 于是我就毫不蛋疼的去 google 了, 而且还在他俩的社区提了这个问题! 终于, 在我的努力下弄明白他俩代表的意思了.</p>
<blockquote>
<p>先看百度地图 BMKMapView, 代表的就是Baidu Map Kit MapView<br>再看高德地图 MAMapView,   “A map”就是一张地图，这个品牌的诞生就是为了做好一张地图</p>
</blockquote>
<p>对于地图开发, 我觉得还应该从高处把握, 然后一点一点往下剥, 思路会非常清晰. 其实, 不单单是地图开发, 对于其他知识的学习也应该从高处把握, 否则, 会感觉凌乱, 没有头绪. 下面我们就看看怎么从高处把握地图开发的框架. (以高德地图为例, 百度地图其实也是一样的, 只是换了个名字).</p>
<p>我觉得这个”高”主要体现在两个方面, 一个是把握好下面这些类, 而这些类就是一个主线, 是形成在我们脑海里的主干线路, 要理清楚哪一条道是转弯道, 哪一条道是单行道, 哪一条是非机动车道, 每一个类的功能都了然于胸, 用的时候自然而然很快速的找到我们所需要的.</p>
<table>
<thead>
<tr>
<th>类</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>BMKMapView</td>
<td>地图显示</td>
</tr>
<tr>
<td>BMKLocationService</td>
<td>定位</td>
</tr>
<tr>
<td>BMKPoisearch</td>
<td>周边检索</td>
</tr>
<tr>
<td>BMKAnnotationView</td>
<td>标注</td>
</tr>
<tr>
<td>BMKGeoCodeSearch</td>
<td>地理编码</td>
</tr>
<tr>
<td>BMKOverlayView</td>
<td>覆盖物图层</td>
</tr>
<tr>
<td>BMKOfflineMap</td>
<td>离线地图</td>
</tr>
</tbody>
</table>
<p>上面是百度地图的一些类, 高德地图其实是一样的, 就是名字变了而已.</p>
<table>
<thead>
<tr>
<th>类</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>MAMapView</td>
<td>地图显示</td>
</tr>
<tr>
<td>MAUserLocation</td>
<td>定位</td>
</tr>
<tr>
<td>AMapSearchAPI</td>
<td>周边检索</td>
</tr>
<tr>
<td>MAAnnotationView</td>
<td>标注</td>
</tr>
<tr>
<td>AMapGeocode</td>
<td>地理编码</td>
</tr>
<tr>
<td>MAOverlayView</td>
<td>覆盖物图层</td>
</tr>
<tr>
<td>MAOfflineMap</td>
<td>离线地图</td>
</tr>
</tbody>
</table>
<p>这个地方你就会明白为什么开头会讲到他俩英文命名的含义了吧. 后面要说到的方法也是这个道理, 咱们要找到共性, 区别差异. 所以, 更简单的就是7个英文单词.</p>
<table>
<thead>
<tr>
<th>主干</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>MapView</td>
<td>地图显示</td>
</tr>
<tr>
<td>Location</td>
<td>定位</td>
</tr>
<tr>
<td>Search</td>
<td>周边检索</td>
</tr>
<tr>
<td>Annotation</td>
<td>标注</td>
</tr>
<tr>
<td>Geocode</td>
<td>地理编码</td>
</tr>
<tr>
<td>Overlay</td>
<td>覆盖物图层</td>
</tr>
<tr>
<td>Offline</td>
<td>离线地图</td>
</tr>
</tbody>
</table>
<p>所以, 你不用为一长串一长串的方法苦恼了, 这是一个单词匹对的游戏.</p>
<p>好了, 目前为止咱们这个主干就建立起来了, 有什么需求就尽管提吧. 拿最基本的一个需求来说吧—地图显示. 根据咱们的主干知识, 快速定位, 很明了, 就是 MAMapView. 到这就要用到我之前博客里说到的方法<a href="http://www.jianshu.com/p/2d4693cbdbd7" target="_blank" rel="noopener">《iOS 学习技巧之”查”》</a>, 点进去看, 所有接口都可以看到，并且都有注释，应该说是很好理解了.</p>
<p>当然, 除此之外, 再配合百度地图和高德地图官方资料教程, 以及 google 的各种资料, 拿下地图这一块不是问题.</p>
<p>最后分享一些资料给大家</p>
<p><a href="http://lbs.amap.com/api/ios-sdk/summary/" target="_blank" rel="noopener">概述 高德地图 API</a></p>
<p><a href="http://lbs.amap.com/Public/reference/iOS%20API%20v2_3D/interface_m_a_offline_map.html" target="_blank" rel="noopener">高德地图 iOS SDK 3D 地图&amp;搜索服务参考手册 V2.4.1</a></p>
<p>高德地图视频教程</p>
<p><a href="http://v.youku.com/v_show/id_XODI2NTQyMTMy.html?firsttime=0" target="_blank" rel="noopener">如何使用 iOS SDK 进行开发01——开发你的第一个地图应用</a></p>
<p><a href="http://v.youku.com/v_show/id_XODI2NTQ4Njg0.html" target="_blank" rel="noopener">如何使用 iOS SDK 进行开发02——附近搜索</a></p>
<p><a href="http://v.youku.com/v_show/id_XODI2NTQ5NjQ4.html" target="_blank" rel="noopener">如何使用 iOS SDK 进行开发03——自定义 AnnotationView</a></p>
<p><a href="http://v.youku.com/v_show/id_XODI2NTUxNjU2.html" target="_blank" rel="noopener">如何使用 iOS SDK 进行开发04——路线规划</a></p>
<p>高德地图开发者认证群: 253476702</p>
<p><a href="http://www.cnblogs.com/milkmap/tag/%E5%9C%B0%E5%9B%BEAPI/" target="_blank" rel="noopener">http://www.cnblogs.com/milkmap/tag/%E5%9C%B0%E5%9B%BEAPI/</a></p>
<p><a href="http://developer.baidu.com/map/index.php?title=iossdk/guide/introduction" target="_blank" rel="noopener">百度地图开发指南</a></p>
<p><a href="http://wiki.lbsyun.baidu.com/cms/iossdk/doc/v2_6_0/BaiduMap_IOSSDK_v2.6.0_Docs/html/annotated.html" target="_blank" rel="noopener">百度地图 SDK for iOS v2.6.0 类参考</a></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/30/深入理解Block 2/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-30T22:24:08+08:00" content="2018-04-30">
              2018-04-30
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://upload-images.jianshu.io/upload_images/193863-25c000d7acb449ad?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="来自 Lili Popper 的作品"></p>
<h3 id="一-Block概要"><a href="#一-Block概要" class="headerlink" title="一.Block概要"></a>一.Block概要</h3><h4 id="什么是Block"><a href="#什么是Block" class="headerlink" title="什么是Block"></a>什么是Block</h4><blockquote>
<p>Block objects are a C-level syntactic and runtime feature. They are similar to standard C functions, but in addition to executable code they may also contain variable bindings to automatic (stack) or managed (heap) memory. A block can therefore maintain a set of state (data) that it can use to impact behavior when executed.</p>
<p>怎么理解这段话? 可以分成两段来理解:</p>
<ul>
<li>Block 对象是一个C语言级别的语法和运行时特征: Block的形式跟C语言中函数指针的形式基本相似(后文会有讲到)</li>
<li>包含stack或者heap中的内存的变量: Block带有自动变量</li>
</ul>
</blockquote>
<p>所以, 可以用一句话来表示Block:<strong>带有自动变量(局部变量)的匿名函数</strong>.</p>
<p>下面看一个C语言函数的例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个名为func的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span> <span class="params">(<span class="keyword">int</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用这个函数</span></span><br><span class="line"><span class="keyword">int</span> result = func (<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数指针来代替直接调用函数</span></span><br><span class="line"><span class="keyword">int</span> result = (* funcptr) (<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>看着似乎不用知道函数名也能够使用该函数,但其实使用函数指针也仍然需要知道函数名称.</p>
<p>在赋值给函数指针时,若不使用想赋值的函数名称,就无法取得该函数的地址.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (* funcptr) (<span class="keyword">int</span>) = &amp;func;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = (*funcptr) (<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<p>iOS中的Block, 在其他许多程序语言中叫做: 闭包 (Closure)、lambda计算、Anonymous function等.</p>
<h3 id="二-Block模式"><a href="#二-Block模式" class="headerlink" title="二.Block模式"></a>二.Block模式</h3><h4 id="1-Block表达式语法-Block-Literal-Syntax"><a href="#1-Block表达式语法-Block-Literal-Syntax" class="headerlink" title="1.Block表达式语法 (Block Literal Syntax)"></a>1.Block表达式语法 (Block Literal Syntax)</h4><p>基本表达式: <code>^</code> <code>返回值类型</code> <code>参数列表</code> <code>表达式</code></p>
<p>最省表达式: <code>^</code> <code>表达式</code></p>
<p>使用typedef定义: <code>typedef int (^blk_t) (int);</code></p>
<p>死活就是记不住?不要紧,随时可以访问”国际著名Block声明网站”<a href="http://fuckingblocksyntax.com/" target="_blank" rel="noopener">How Do I Declare A Block in Objective-C?</a></p>
<blockquote>
<p>通过使用typedef,函数定义就变得更容易理解了.另外,将赋值给Block类型变量中得Block方法像C语言通常的函数调用那样使用,这种方法与使用函数指针类型变量调用函数的方法几乎完全相同.</p>
</blockquote>
<p>变量funcptr为函数指针类型时, 像下面这样调用函数指针类型变量:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = (* funcptr) (<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<p>变量blk为Block类型的情况下, 这样调用Block类型变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int result = bulk(10);</span><br></pre></td></tr></table></figure></p>
<p>是不是很相似,这个就是文章开头提到的Block和函数指针.</p>
<h4 id="2-Block类型变量"><a href="#2-Block类型变量" class="headerlink" title="2.Block类型变量"></a>2.Block类型变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (^blk) (<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<p>与前面的使用函数指针的源代码对比可知,声明Block类型变量仅仅是将声明函数指针类型变量的”*”变为”^”.该Block类型变量与一般的C语言变量完全相同, 可作为以下用途使用.</p>
<ul>
<li><p>自动变量</p>
</li>
<li><p>函数参数</p>
</li>
<li><p>静态变量</p>
</li>
<li><p>静态全局变量</p>
</li>
<li><p>全局变量</p>
</li>
</ul>
<h4 id="3-截获自动变量值"><a href="#3-截获自动变量值" class="headerlink" title="3.截获自动变量值"></a>3.截获自动变量值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main () &#123;</span><br><span class="line"></span><br><span class="line">    int dmy = 256;</span><br><span class="line">    int val = 10;</span><br><span class="line">    const char *fmt = &quot;val = %d\n&quot;;</span><br><span class="line">    void (^blk)(void) = ^&#123;printf(fmt, val);&#125;;</span><br><span class="line">    </span><br><span class="line">    val = 2;</span><br><span class="line">    fmt = &quot;Test values were changed. val = %d\n&quot;;</span><br><span class="line">    </span><br><span class="line">    blk ();</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后发现val的值并没有发生变化,这是因为Block表达式保存了自动变量的值,也就是说截获了val和*fmt.</p>
<h4 id="4-block说明符"><a href="#4-block说明符" class="headerlink" title="4.__block说明符"></a>4.__block说明符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int val = 0;</span><br><span class="line"></span><br><span class="line">void (^blk) (void) = ^&#123;</span><br><span class="line"></span><br><span class="line">     val = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">blk();</span><br><span class="line"></span><br><span class="line">printf(&quot;val = %d\n&quot;, val);</span><br><span class="line"></span><br><span class="line">// val = 0;</span><br></pre></td></tr></table></figure>
<p>在这个地方可以看到,我们在block外面打印了val,但是值并没有改变,那么我们若想在Block语法的表达式中将值赋给在Block语法外声明的自动变量, 需要在该自动变量上附加__block说明符.</p>
<p>思考思考下面两句话</p>
<blockquote>
<p>block会截获局部变量,但仅仅是截获,值传递到block内,可以【读】局部变量的值;</p>
<p>加了 __block 就是用了个结构体进行指针传递，可以【读<strong><strong> / </strong></strong>写】这个局部变量;</p>
</blockquote>
<h4 id="5-截获的自动变量"><a href="#5-截获的自动变量" class="headerlink" title="5.截获的自动变量"></a>5.截获的自动变量</h4><h3 id="三-Block的实现"><a href="#三-Block的实现" class="headerlink" title="三.Block的实现"></a>三.Block的实现</h3><h4 id="1-Block的实质"><a href="#1-Block的实质" class="headerlink" title="1.Block的实质"></a>1.Block的实质</h4><p>用clang(LLVM编译器)将含有Block语法的源代码转换为C++的源代码.</p>
<p><code>clang -rewrite-objc 源代码文件名</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 10;</span><br><span class="line">    </span><br><span class="line">    int j = 1;</span><br><span class="line">    </span><br><span class="line">    void (^blk)(void);</span><br><span class="line">    </span><br><span class="line">    blk = ^&#123;</span><br><span class="line">        </span><br><span class="line">        printf(&quot;i:%d, j:%d&quot;, i, j);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    i = 1024;</span><br><span class="line">    j = 2048;</span><br><span class="line">    </span><br><span class="line">    blk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_i_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_i_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> _i, <span class="keyword">int</span> _j, <span class="keyword">int</span> flags=<span class="number">0</span>) : i(_i), j(_j) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> i = __cself-&gt;i; <span class="comment">// bound by copy</span></span><br><span class="line">  <span class="keyword">int</span> j = __cself-&gt;j; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i:%d, j:%d"</span>, i, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure>
<p>下面我们就来分析一下Block结构</p>
<p>首先是block主题结构体__main_block_impl_0</p>
<p>第一个成员变量是impl</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> Flags;</span><br><span class="line">    <span class="keyword">int</span> Reserved;</span><br><span class="line">    <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>isa指针说明block是一个objc对象.</p>
<p>第二个成员变量是Desc指针<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个结构体的构造函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> _j, __Block_byref_i_0 *_i, <span class="keyword">int</span> flags=<span class="number">0</span>) : j(_j), i(_i-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>以上就是一个没有成员变量Block的__main_block_impl_0结构体成员</p>
<p>其次block执行函数__main_block_func_0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> i = __cself-&gt;i; <span class="comment">// bound by copy</span></span><br><span class="line">  <span class="keyword">int</span> j = __cself-&gt;j; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i:%d, j:%d"</span>, i, j);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最后是block的描述信息结构体__main_block_desc_0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-截获自动变量值"><a href="#2-截获自动变量值" class="headerlink" title="2.截获自动变量值"></a>2.截获自动变量值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> _i, <span class="keyword">int</span> _j, <span class="keyword">int</span> flags=<span class="number">0</span>) : i(_i), j(_j) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从Block的主体结构可以看到,原本在blcok外部的自动变量 int i 和 int j 被保存到了Block的结构体实例中.此时的j已经不是原来的j了,相当于值拷贝.</p>
<blockquote>
<p>值类型和引用类型的区别</p>
</blockquote>
<h4 id="3-block说明符"><a href="#3-block说明符" class="headerlink" title="3.__block说明符"></a>3.__block说明符</h4><p>上面用clang编译的代码是没有用<strong>block修饰的,下面我们来看看加上</strong>block修饰符后发生了哪些变化</p>
<p>给变量int i 加上__block修饰符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    __block int i = 10;</span><br><span class="line">    </span><br><span class="line">    int j = 1;</span><br><span class="line">    </span><br><span class="line">    void (^blk)(void);</span><br><span class="line">    </span><br><span class="line">    blk = ^&#123;</span><br><span class="line">        </span><br><span class="line">        printf(&quot;i:%d, j:%d&quot;, i, j);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    i = 1024;</span><br><span class="line">    j = 2048;</span><br><span class="line">    </span><br><span class="line">    blk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用clang编译后的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_i_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_i_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  int j;</span><br><span class="line">  __Block_byref_i_0 *i; // by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _j, __Block_byref_i_0 *_i, int flags=0) : j(_j), i(_i-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_i_0 *i = __cself-&gt;i; // bound by ref</span><br><span class="line">  int j = __cself-&gt;j; // bound by copy</span><br><span class="line"></span><br><span class="line">        printf(&quot;i:%d, j:%d&quot;, (i-&gt;__forwarding-&gt;i), j);</span><br><span class="line">    &#125;</span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br></pre></td></tr></table></figure>
<p>可以上下对比一下,只是给变量 int i 加了__block修饰符就多出这么多代码</p>
<p>全局变量 局部变量</p>
<p>__block存储域类说明符 ( _block storage-class-specifier)</p>
<p>__block说明符类似于static、auto和register说明符, 他们用于指定将变量值设置到哪个存储领域中.</p>
<p>__block修饰的变量val在源码中也会转换为结构体实例</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_i_0 &#123;</span><br><span class="line">  void *__isa<span class="comment">;</span></span><br><span class="line">__Block_byref_i_0 *__forwarding<span class="comment">;</span></span><br><span class="line"> int __flags<span class="comment">;</span></span><br><span class="line"> int __size<span class="comment">;</span></span><br><span class="line"> int i<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>__block变量也同Block一样变成_Block_byref_val_0结构体类型的自动变量, 即栈上生成的_Block_byref_val_0结构体实例.</p>
<p>我们发现val这个变量出现在了结构体实例的初始化中,这意味着该结构体持有相当于原自动变量的成员变量.</p>
<p>_Block_byref_val_0结构体实例的成员变量<strong>forwarding持有指向该实例自身的指针. 通过成员变量</strong>forwarding访问成员变量val.</p>
<h4 id="4-Block存储域"><a href="#4-Block存储域" class="headerlink" title="4.Block存储域"></a>4.Block存储域</h4><p>Block转换为Block的结构体类型的自动变量,<strong>block变量转换为</strong>block变量的结构体类型的自动变量. 所谓结构体类型的自动变量, 即栈上生成的该结构体的实例.</p>
<h5 id="三种类型的Block"><a href="#三种类型的Block" class="headerlink" title="三种类型的Block:"></a>三种类型的Block:</h5><blockquote>
<p>NSConcreteStackBlock</p>
<p>NSConcreteGlobalBlock</p>
<ul>
<li>记述全局变量的地方有Block语法时</li>
<li>Block语法的表达式中不使用应截获的自动变量时</li>
</ul>
<p>NSConcreteMallocBlock</p>
</blockquote>
<p>#####两个问题</p>
<ul>
<li>Block超出变量作用域可存在的原因</li>
<li><strong>block变量用结构体成员变量</strong>forwarding存在的原因</li>
</ul>
<p>如何解决: 从栈上复制到堆上 (想到定义Block属性的时候为什么用copy了)</p>
<p>编译器不能判断的状况:</p>
<ul>
<li>向方法或函数的参数中传递Block时</li>
<li>Cocoa 框架的方法且方法名中含有usingBlock等时</li>
<li>Grand Central Dispatch 的 API</li>
</ul>
<p>NSArray类的initWithObjects实例方法上传递Block时需要手动复制</p>
<h4 id="5-block变量存储域"><a href="#5-block变量存储域" class="headerlink" title="5.__block变量存储域"></a>5.__block变量存储域</h4><h4 id="6-截获对象"><a href="#6-截获对象" class="headerlink" title="6.截获对象"></a>6.截获对象</h4><p>什么时候栈上的Block会复制到堆上呢?</p>
<ul>
<li>调用Block的copy实例方法时</li>
<li>Block作为函数返回值返回时</li>
<li>将Block赋值给附有__strong修饰符id类型的类或Block类型成员变量时</li>
<li>在方法名中含有usingBlock的Cocoa框架方法或Grand Central Dispatch的API中传递Block时</li>
</ul>
<h4 id="7-block变量和对象"><a href="#7-block变量和对象" class="headerlink" title="7.__block变量和对象"></a>7.__block变量和对象</h4><h4 id="8-Block循环引用"><a href="#8-Block循环引用" class="headerlink" title="8.Block循环引用"></a>8.Block循环引用</h4><h5 id="self循环引用"><a href="#self循环引用" class="headerlink" title="self循环引用"></a>self循环引用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.myblock = ^&#123;</span><br><span class="line"></span><br><span class="line">        [self doSomething];</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>上面的这个例子, 就是典型的一个循环引用. self持有myblock, 而myblock又持有self.</p>
<h5 id="self隐式循环引用"><a href="#self隐式循环引用" class="headerlink" title="self隐式循环引用"></a>self隐式循环引用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line">&#123;</span><br><span class="line">    int _number;</span><br><span class="line">    void (^_block)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">  void (^_block)() = ^&#123;</span><br><span class="line">        _number = 10;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子, 虽然没有出现self,但是同样的会造成循环引用.这也是解决了一些朋友误认为Block的循环引用是跟self有关的误解.</p>
<p>因为如果在Block中使用附有__strong修饰符的对象类型自动变量, 那么当Block从栈复制到堆时, 该对象为Block所持有.</p>
<p>所以在用到Block时,推荐大家使用property,不用内部变量.</p>
<h5 id="防止循环引用"><a href="#防止循环引用" class="headerlink" title="防止循环引用"></a>防止循环引用</h5><p>知道了循环引用产生的原因,就可以对症下药了. 下面三种方式都可以避免循环引用, 但是他们的使用条件和场景不同</p>
<p>__weak</p>
<p>__unsafe_unretained</p>
<p>__block</p>
<blockquote>
<p><strong>weak本身是可以避免循环引用的问题的,但是其会导致外部对象释放了之后,block内部也访问不到这个对象的问题,我们可以通过在block 内部声明一个</strong>strong的变量来指向weakObj,使外部对象既能在 block 内部保持住,又能避免循环引用的问题.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__weak __typeof(self)weakSelf = self;</span><br><span class="line">AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">    __strong __typeof(weakSelf)strongSelf = weakSelf;</span><br><span class="line">    strongSelf.networkReachabilityStatus = status;</span><br><span class="line">    if (strongSelf.networkReachabilityStatusBlock) &#123;</span><br><span class="line">        strongSelf.networkReachabilityStatusBlock(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>AFNetworking中block例子</p>
<p>常看到一个 block 要使用 self,会处理成在外部声明一个 weak 变量指向 self,在 block 里又声明一个 strong 变量指向 weakSelf:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__weak __typeof(self)weakSelf = self; </span><br><span class="line">self.backgroundTaskIdentifier = [application beginBackgroundTaskWithExpirationHandler:^&#123; </span><br><span class="line">    __strong __typeof(weakSelf)strongSelf = weakSelf; </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>weakSelf是为了block不持有self，避免循环引用，而再声明一个strongSelf是因为一旦进入block执行，就不允许self在这个执行过程中释放。block执行完后这个strongSelf会自动释放，没有循环引用问题。</p>
<blockquote>
<p>__block避免循环引用时,我们必须在block内部手动把block变量置为nil.否则是无法避免循环引用的.</p>
<p>使用__block防止循环引用的优缺点:</p>
<p>优点:</p>
<ul>
<li>通过__block变量可控制对象的持有期间</li>
<li>在不能使用_weak修饰符的环境中不使用_unsafe_unretained修饰符即可</li>
</ul>
<p>缺点:</p>
<ul>
<li>为避免循环引用必须手动把block变量置为nil</li>
</ul>
</blockquote>
<h3 id="合理使用-Block"><a href="#合理使用-Block" class="headerlink" title="合理使用 Block"></a>合理使用 Block</h3><p>合理使用 Block 可以让我们的代码结构紧凑，简化问题，但是一旦大量或者不分场合的使用 Block，势必会造成代码可读性差的问题。基于这个原因，除了很适合 Block 和 Notification 场景情况下，我都会用 Delegate 去实现。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/30/KVO-NSNotification/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-30T22:24:08+08:00" content="2018-04-30">
              2018-04-30
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p></p><p></p>
<h2 id="NSNotification-通知中心"><a href="#NSNotification-通知中心" class="headerlink" title="NSNotification 通知中心"></a>NSNotification 通知中心</h2><p></p><p></p>
<p>苹果提供的一种消息机制, 观察者只要向消息中心注册， 即可接受其他对象发送来的消息，消息发送者和消息接受者两者可以互相一无所知，完全解耦。NSNotification可以应用于任意时间和任何对象，观察者可以有多个, 这也正是他跟delegate的区别.</p>
<p>####使用步骤:</p>
<ol>
<li>注册一个观察者</li>
<li>给通知中心发送一个消息</li>
<li>清除观察者</li>
</ol>
<p>####代码:</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">  *  注册一个观察者</span><br><span class="line">  *</span><br><span class="line">  *  @param observer 谁去接受消息, 执行方法</span><br><span class="line">  *  @param selector 一旦接收到消息, 要执行的方法</span><br><span class="line">  *  @param name 要监听的事件, 以字符串区分</span><br><span class="line">  *  @param object 限定发出消息的对象</span><br><span class="line">  */</span><br><span class="line">- (void)addObserver:(id)observer selector:(SEL)aSelector name:(NSString *)aName object:(id)anObject;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```2.给通知中心发布消息</span><br></pre></td></tr></table></figure>


/**
 *  给通知中心发布消息
 *
 *  @param notification 传递一个通知
 */
- (void)postNotification:(NSNotification *)notification;


/**
 *  给通知中心发布消息
 *
 *  @param aName    事件名称
 *  @param anObject 给消息的接受者传递一个参数
 */
- (void)postNotificationName:(NSString *)aName object:(id)anObject;


/**
 *  给通知中心发布消息
 *
 *  @param aName     事件的名称
 *  @param anObject  给消息的接受者传递一个参数
 *  @param aUserInfo 多个参数以字典形式传递
 */
- (void)postNotificationName:(NSString *)aName object:(id)anObject userInfo:(NSDictionary *)aUserInfo;



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     *  移除全部观察者</span><br><span class="line">     *</span><br><span class="line">     *  @param observer &lt;#observer description#&gt;</span><br><span class="line">     */</span><br><span class="line">    - (void)removeObserver:(id)observer;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  移除指定观察者</span><br><span class="line">     *</span><br><span class="line">     *  @param observer &lt;#observer description#&gt;</span><br><span class="line">     *  @param aName    &lt;#aName description#&gt;</span><br><span class="line">     *  @param anObject &lt;#anObject description#&gt;</span><br><span class="line">     */</span><br><span class="line">    - (void)removeObserver:(id)observer name:(NSString *)aName object:(id)anObject;</span><br><span class="line"></span><br><span class="line">####应用场景:</span><br><span class="line"></span><br><span class="line">1. 控制器与一个或多个任意的对象进行通信(监控)</span><br><span class="line">2. UIDevice通知</span><br><span class="line">3. 键盘通知</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/p&gt;</span><br><span class="line">## KVO</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">Key-Value Observing，是Foundation框架提供的一种机制，使用KVO，可以方便地对指定对象的某个属性进行观察，当属性发生变化时，进行通知.        </span><br><span class="line">        </span><br><span class="line">#### 实现步骤</span><br><span class="line"></span><br><span class="line">1. 由被观察的对象调用方法, 添加观察者 </span><br><span class="line">2. 一旦被观察的属性发生改变, 系统会调用这个方法</span><br><span class="line">3. 解除观察者身份 </span><br><span class="line"></span><br><span class="line">#### 代码</span><br><span class="line"></span><br><span class="line">    ```1. 添加观察者</span><br></pre></td></tr></table></figure>

/**
 *  由被观察的对象调用方法, 添加观察者
 *
 *  @param observer 观察者
 *  @param keyPath  观察(监控)哪一个属性
 *  @param options  设定通知观察者时传递的属性值，是传改变前的呢，还是改变后的
 *  @param context  一些其他的需要传递给观察者的上下文信息，通常设置为nil
 */
- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context;


<figure class="highlight plain"><figcaption><span>一旦被观察的属性发生变化, 系统就会调用这个方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  必须要实现的方法</span><br><span class="line"> *</span><br><span class="line"> *  @param keyPath 监控的属性</span><br><span class="line"> *  @param object  是我们 监听的对象</span><br><span class="line"> *  @param change  里面包含了keyPath对应的新值</span><br><span class="line"> *  @param context 一些其他的需要传递给观察者的上下文信息，通常设置为nil</span><br><span class="line"> */</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```3. 移除观察者</span><br></pre></td></tr></table></figure>

/**
 *  解除观察者的身份
 *
 *  @param observer 观察者
 *  @param keyPath  监控的属性
 */
- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;
</code></pre><p>需要注意的是, 在ARC和MRC下都要移除观察者, 在ARC下不调用[super dealloc]</p>
<p></p><p></p>
<h4 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章:"></a>相关文章:</h4><ol>
<li><a href="http://www.kyleduo.com/?p=270" target="_blank" rel="noopener">http://www.kyleduo.com/?p=270</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSNotification_Class/index.html" target="_blank" rel="noopener">https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSNotification_Class/index.html</a></li>
<li><a href="http://mobile.51cto.com/iphone-386316.htm" target="_blank" rel="noopener">http://mobile.51cto.com/iphone-386316.htm</a></li>
<li><a href="http://www.jianshu.com/users/65e7fdcab03c/latest_articles" target="_blank" rel="noopener">http://www.jianshu.com/users/65e7fdcab03c/latest_articles</a></li>
<li><a href="http://www.hpique.com/2013/12/nsnotificationcenter-part-1/" target="_blank" rel="noopener">http://www.hpique.com/2013/12/nsnotificationcenter-part-1/</a></li>
</ol>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/30/iOS歌词解析/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-30T22:24:08+08:00" content="2018-04-30">
              2018-04-30
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前,写了一个关于莫文蔚的app,因为版权的问题被苹果拒了,然后也再没动,这几天又拿出来看了看,感觉歌词解析这部分挺有意思的,拿出来说一说.</p>
<p>这个是做好的效果<br><img src="http://upload-images.jianshu.io/upload_images/193863-d999b1e2b70ffa59.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>首先,我们来看看歌词都是怎么展示的,下几个音乐类软件看看,能滚动,被选中的歌词高亮,都是这两个特点,所以猜测是用tableview来显示歌词的.拿虾米验证了一下果然是.</p>
<p>然后,我们要弄明白lrc歌词有哪些格式,上网查,或者抓包都可以看到.一般来说lrc歌词有三种格式:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/193863-bd5f047be5f07757.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="格式一"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/193863-d7da602bdf5c907a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="格式二"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/193863-63a17f53dbfab6e5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="格式三"></p>
<p>其实还有一种格式, 是像KTV一样的效果, 每个字对应一个时间点, 在这咱们也用不到就不列举了.</p>
<p> 明白了上面的两点,我们来看看整体的思路,其实就两点:<br>       1.歌词解析<br>       2.动态显示<br> 那么,咱们继续往下展开.先来看歌词解析</p>
<p> 一般情况下,只需要解析一种格式就可以了,但是,问题是这些歌词都是抓的接口,我们所要做的就是把这三种格式都解析出来.这个地方其实涉及到一个思维的问题,如果你一开始就想着怎么把这三种格式都解析出来,恐怕是很困难的.所以我们找一个好上手的,先解析出来一个,然后再去关注另外两种.</p>
<p> 附上部分代码</p>
<pre><code>NSArray *array = [contentString componentsSeparatedByString:@&quot;\n&quot;];

for (int i = 0; i &lt; [array count]; i++) {

    NSString *lineString = [array objectAtIndex:i];

    NSArray *lineArray = [lineString componentsSeparatedByString:@&quot;]&quot;];

    if ([lineArray[0] length] &gt; 8) {

        NSString *str1 = [lineString substringWithRange:NSMakeRange(3, 1)];

        NSString *str2 = [lineString substringWithRange:NSMakeRange(6, 1)];

        if ([str1 isEqualToString:@&quot;:&quot;] &amp;&amp; [str2 isEqualToString:@&quot;.&quot;]) {

            for (int i = 0; i &lt; lineArray.count - 1; i++) {

                NSString *lrcString = [lineArray objectAtIndex:lineArray.count - 1];

                //分割区间求歌词时间
                NSString *timeString = [self timeToSecond:[[lineArray objectAtIndex:i] substringWithRange:NSMakeRange(1, 5)]];

                self.lrcDictionary = [NSMutableDictionary dictionary];

                //把时间 和 歌词 加入词典
                [self.lrcDictionary setObject:lrcString forKey:timeString];
              }
          }
      }
  }
</code></pre><p>这一步咱们就把歌词解析出来了,放到了一个字典当中.以上还有两个要注意的问题,一是要把<em>时间转换为秒</em>,二是要给解析出来的歌词<em>按照时间排序</em>.</p>
<p>解析歌词的部分就完成了,剩下的任务就是动态显示了,怎么能够让歌词动态显示呢,主要用到下面两个方法:<br>       1.NSTimer<br>       2.被选中的行移动到中间<br>       <code>- (void)selectRowAtIndexPath:(NSIndexPath*)indexPath animated:(BOOL)animated scrollPosition:(UITableViewScrollPosition)scrollPosition;</code></p>
<p>在这里注意的是,定义一个NSUInteger,表示当前歌词行数,通过NSTimer每次把NSUInteger传到<br><code>selectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated scrollPosition:(UITableViewScrollPosition)scrollPosition</code><br>这个方法.</p>
<pre><code>// 使被选中的行移到中间
NSIndexPath *indexPath = [NSIndexPath indexPathForRow:lineNumber inSection:0];
[self.lrcTableView selectRowAtIndexPath:indexPath animated:YES scrollPosition:UITableViewScrollPositionMiddle];
</code></pre><p>至此,整个思路就完成了,中间肯定有很多的细节问题需要处理,由于暂时没想好怎么去说这些细节的东西,留待以后如果有思路再补充.</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ww1.sinaimg.cn/mw690/8edca89bgw1f2rp95fpbjj208c08ct9y.jpg"
               alt="Brave" />
          <p class="site-author-name" itemprop="name">Brave</p>
          <p class="site-description motion-element" itemprop="description">只要思想不滑坡 办法总比困难多</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">21</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/BraveMatchstickMen" target="_blank">
                  
                    <i class="fa fa-globe"></i>
                  
                  github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.weibo.com/2396825755" target="_blank">
                  
                    <i class="fa fa-globe"></i>
                  
                  weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/users/fddb055efe32/latest_articles" target="_blank">
                  
                    <i class="fa fa-globe"></i>
                  
                  jianshu
                </a>
              </span>
            
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
            <div class="links-of-blogroll-title">Links</div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://xingren.com" target="_blank">杏仁医生</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://hack.xingren.com/2016/03/29/webpack%E5%85%A5%E9%97%A8/" target="_blank">杏仁技术博客</a>
                </li>
              
            </ul>
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Brave</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>





      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
