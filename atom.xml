<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>时空人</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.chusaikeji.com/"/>
  <updated>2018-04-30T15:26:16.000Z</updated>
  <id>http://blog.chusaikeji.com/</id>
  
  <author>
    <name>Brave</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Runtime</title>
    <link href="http://blog.chusaikeji.com/2016/07/01/Runtime/"/>
    <id>http://blog.chusaikeji.com/2016/07/01/Runtime/</id>
    <published>2016-07-01T10:13:04.000Z</published>
    <updated>2018-04-30T15:26:16.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8edca89bgw1f2vzgvtsukj20qo0hs405.jpg&quot; alt=&quot;图片来自网络&quot;&gt;&lt;/p&gt;
&lt;p&gt;故事要从一次崩溃开始。。。&lt;/p&gt;
&lt;p&gt;由于你的粗心大意，调用了一个只声明没有实现的方法，结果你肯定知道了。是的，程序崩溃了。如果你打了全局断点，很容易找到问题出在哪了。但是，我们的讨论不止于此，我们要深入方法调用的背后，看看这期间到底发生了哪些事情。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Runtime&quot;&gt;&lt;a href=&quot;#Runtime&quot; class=&quot;headerlink&quot; title=&quot;Runtime&quot;&gt;&lt;/a&gt;Runtime&lt;/h3&gt;&lt;p&gt;正如你所知道的 Objective-C 是一门动态语言，所以只有在运行时它才会做一些决定性工作。这也就是说为什么在编译阶段，你调用了一个没有声明的方法，编译器不会报红。对于这一点，C 语言恰恰是相反的，他会在编译阶段就告诉你，你调用了一个没有实现过的方法。&lt;/p&gt;
&lt;p&gt;既然如此， Objective-C 不仅仅需要一个编译器，而且也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。这个运行时系统就是我们今天的主人公 &lt;strong&gt;Runtime&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;Runtime 是用 C 和汇编写的，而且是开源的，点击&lt;a href=&quot;http://opensource。apple。com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;可以下载到它。&lt;/p&gt;
&lt;h3 id=&quot;消息传递&quot;&gt;&lt;a href=&quot;#消息传递&quot; class=&quot;headerlink&quot; title=&quot;消息传递&quot;&gt;&lt;/a&gt;消息传递&lt;/h3&gt;&lt;p&gt;当我们在屏幕上敲出&lt;code&gt;[self doSomething]&lt;/code&gt;这一行代码时，编译器会对 Objective-C 代码做分析检查， 并把它翻译成一个C的函数调用，如下&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;objc_msgSend&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self， doSomething)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;检测 self 是不是 nil，如果是则会直接忽略。&lt;/li&gt;
&lt;li&gt;方法的调用者会通过 isa 指针来找到其所属的类，然后在 cache 或者 methodLists 中查找该方法，找得到就跳到对应的方法去执行。&lt;/li&gt;
&lt;li&gt;如果 class 中没有找到对应的方法，继续往它的 superclass 中找，如果还没找到会继续往上找，直到找到 NSObject 类为止。(如下图)&lt;/li&gt;
&lt;li&gt;一旦找到对应的函数，就去执行它的实现 IMP。如果没有找到就会进入消息转发。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4。sinaimg。cn/mw690/8edca89bgw1f5c6x679t3j20hd0i8jsz。jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www。sealiesoftware。com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses。html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图片来自objc_explain_Classes_and_metaclasses&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;动态方法解析和转发&quot;&gt;&lt;a href=&quot;#动态方法解析和转发&quot; class=&quot;headerlink&quot; title=&quot;动态方法解析和转发&quot;&gt;&lt;/a&gt;动态方法解析和转发&lt;/h3&gt;&lt;p&gt;在上面的消息传递中，如果一直没有找到对应的函数，没有其他设置的话，就是我们在一开始提到的从崩溃开始，我们的程序会崩溃。但是在程序崩溃前， Runtime 会给我们三次拯救程序的机会:&lt;/p&gt;
&lt;p&gt;1。动态方法解析&lt;/p&gt;
&lt;p&gt;2。备用接收者(重定向)&lt;/p&gt;
&lt;p&gt;3。消息转发&lt;/p&gt;
&lt;p&gt;下面我们分别来看看这三次机会&lt;/p&gt;
&lt;h4 id=&quot;动态方法解析&quot;&gt;&lt;a href=&quot;#动态方法解析&quot; class=&quot;headerlink&quot; title=&quot;动态方法解析&quot;&gt;&lt;/a&gt;动态方法解析&lt;/h4&gt;&lt;p&gt;在上面的消息传递中，如果一直没有找到对应的方法， Runtime 会发送 &lt;code&gt;+ resolveInstanceMethod:&lt;/code&gt; 或者 &lt;code&gt;+ resolveClassMethod:&lt;/code&gt; 尝试去 resolve 这个消息。调用&lt;code&gt;class_addMethod&lt;/code&gt;添加方法的实现。&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;doSomething&lt;/span&gt;(id self， SEL sel)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;selector-tag&quot;&gt;NSLog&lt;/span&gt;(@&lt;span class=&quot;string&quot;&gt;&quot;%@ %@&quot;&lt;/span&gt;， self， NSStringFromSelector(sel));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (BOOL)&lt;span class=&quot;selector-tag&quot;&gt;resolveInstanceMethod&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:(SEL)sel&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;selector-tag&quot;&gt;if&lt;/span&gt; (sel == &lt;span class=&quot;variable&quot;&gt;@selector&lt;/span&gt;(doSomething)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;selector-tag&quot;&gt;class_addMethod&lt;/span&gt;(self， &lt;span class=&quot;variable&quot;&gt;@selector&lt;/span&gt;(doSomething)， (IMP)doSomething， &lt;span class=&quot;string&quot;&gt;&quot;v@:&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;selector-tag&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;selector-attr&quot;&gt;[super resolveInstanceMethod:sel]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;备用接收者&quot;&gt;&lt;a href=&quot;#备用接收者&quot; class=&quot;headerlink&quot; title=&quot;备用接收者&quot;&gt;&lt;/a&gt;备用接收者&lt;/h4&gt;&lt;p&gt;如果 resolve 方法返回 NO， Runtime 就发送&lt;code&gt;- forwardingTargetForSelector:&lt;/code&gt; 允许你把这个消息转发给另一个对象。切记不能返回 self，这样会进入死循环状态。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (id)forwardingTargetForSelector:(SEL)aSelector&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (aSelector == @selector(eat)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Person *person = [[Person alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        class_addMethod(self。superclass， @selector(eat)， (IMP)eat， &amp;quot;v@:&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return person;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return [super forwardingTargetForSelector:aSelector];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;完整转发&quot;&gt;&lt;a href=&quot;#完整转发&quot; class=&quot;headerlink&quot; title=&quot;完整转发&quot;&gt;&lt;/a&gt;完整转发&lt;/h4&gt;&lt;p&gt;到这一步，是 Runtime 给我们最后一次拯救世界的机会。如果没有新的目标对象返回， Runtime 就会发送 &lt;code&gt;- methodSignatureForSelector:&lt;/code&gt; 和 &lt;code&gt;- forwardInvocation:&lt;/code&gt; 消息。&lt;/p&gt;
&lt;p&gt;首先调用&lt;code&gt;methodSignatureForSelector:&lt;/code&gt;方法，尝试获得一个方法签名。如果获取不到，则直接调用&lt;code&gt;doesNotRecognizeSelector&lt;/code&gt;抛出异常。&lt;/p&gt;
&lt;p&gt;否则就会调用&lt;code&gt;forwardInvocation:&lt;/code&gt;方法，将上一步获取到的方法签名包装成Invocation传入。调用&lt;code&gt;invokeWithTarget:&lt;/code&gt;手动转发消息。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (aSelector == @selector(eat)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSMethodSignature *sig = [NSMethodSignature signatureWithObjCTypes:&amp;quot;v@:&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return sig;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)forwardInvocation:(NSInvocation *)anInvocation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Person *person = [[Person alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ([person respondsToSelector:anInvocation。selector]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [anInvocation invokeWithTarget:person];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        class_addMethod(self。superclass， @selector(eat)， (IMP)eat， &amp;quot;v@:&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Runtime-实例应用&quot;&gt;&lt;a href=&quot;#Runtime-实例应用&quot; class=&quot;headerlink&quot; title=&quot;Runtime 实例应用&quot;&gt;&lt;/a&gt;Runtime 实例应用&lt;/h3&gt;&lt;p&gt;了解了 Runtime 的一些特性，我们就可以根据它的特性做一些很magic的事情，比如:&lt;/p&gt;
&lt;p&gt;1.Method Swizzling&lt;br&gt;2.AOP - Aspect&lt;br&gt;3.JSPatch&lt;br&gt;4.字典与模型的便捷转换&lt;br&gt;5.便捷归档与接档&lt;br&gt;6.Associated Objects&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images。jianshu。io/upload_images/571495-5cd12b17d449bab1。png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;&quot;&gt;图片来自网络&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8edca89bgw1f2vzgvtsukj20qo0hs405.jpg&quot; alt=&quot;图片来自网络&quot;&gt;&lt;/p&gt;
&lt;p&gt;故事要从一次崩溃开始。。。&lt;/p&gt;
&lt;p&gt;由于你的粗心大意，调用了一个只声明没有实现的方法，结果你肯定知道了。是的，程序崩溃了。如果你打了全局断点，很容易找到问题出在哪了。但是，我们的讨论不止于此，我们要深入方法调用的背后，看看这期间到底发生了哪些事情。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://blog.chusaikeji.com/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="http://blog.chusaikeji.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>读源码系列之 WebViewJavascriptBridge</title>
    <link href="http://blog.chusaikeji.com/2016/06/15/%E8%AF%BB%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8BWebViewJavascriptBridge/"/>
    <id>http://blog.chusaikeji.com/2016/06/15/读源码系列之WebViewJavascriptBridge/</id>
    <published>2016-06-15T01:00:36.000Z</published>
    <updated>2018-04-30T15:17:43.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/marcuswestin/WebViewJavascriptBridge&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebViewJavascriptBridge&lt;/a&gt;是我们经常会用到的一个Objective-C与JavaScript交互的第三方.&lt;/p&gt;
&lt;p&gt;想想我们如果不用这个第三方是怎么交互的:&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;iOS 调 JavaScript&lt;/p&gt;
&lt;figure class=&quot;highlight ini&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;[_webView stringByEvaluatingJavaScriptFromString:jsString]&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;JavaScript 调 iOS&lt;/p&gt;
&lt;p&gt;WebView 没法直接调用 iOS,只能触发特定链接,让 iOS 在 WebView 代理方法中捕获到这特定链接,从而执行相应操作,间接实现 WebView 调 iOS.&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)webView:(&lt;span class=&quot;built_in&quot;&gt;UIWebView&lt;/span&gt; *)webView shouldStartLoadWithRequest:(&lt;span class=&quot;built_in&quot;&gt;NSURLRequest&lt;/span&gt; *)request navigationType:(&lt;span class=&quot;built_in&quot;&gt;UIWebViewNavigationType&lt;/span&gt;)navigationType &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; *url = [request URL];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (url == 指定的url) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      [call method]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果 JavaScript 调用 iOS 的方法比较多, 那我们就要在这个代理方法中各种判断 url, 写很长的 if else. 这样的写法从功能上来说肯定是没问题的, 但是从代码规范来看, 却是很糟糕的, 可读性差, 违反单一原则, 耦合度高等问题. 所以, WebViewJavascriptBridge 这个库就是帮我们来解决这个问题的. 下面我们先来看看用他是怎么实现交互的.&lt;/p&gt;
&lt;p&gt;iOS 调 JavaScript&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[_bridge &lt;span class=&quot;string&quot;&gt;callHandler:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;JavaScriptToDo&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;data:&lt;/span&gt;nil];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;JavaScript 调 iOS&lt;/p&gt;
&lt;figure class=&quot;highlight hy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[_bridge registerHandler:@&lt;span class=&quot;string&quot;&gt;&quot;iOSToDo&quot;&lt;/span&gt; handler:^(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;id&lt;/span&gt;&lt;/span&gt; data, WVJBResponseCallback responseCallback) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      [call iOSMethod]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样一看是不是比原生的方法好多了, iOS 调用 JavaScript 时也是一句话, 但是 JavaScript 调用iOS, 不用再去代理方法中判断url. 直接注册一个我们事先协商好的handler, 然后在回调方法中调用iOS方法. 这种做法是不是正好解决了我们再上面提到那些问题.&lt;/p&gt;
&lt;p&gt;WebViewJavascriptBridge 的原理其实还是我们上面说到的系统方法, 只是在这上面封装了一层. 下面我们看一下它的源码.&lt;/p&gt;
&lt;h2 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8edca89bgw1f6tdpwuz0ej20i00a074w.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;一共只有六个文件, 是不是很少! 好了, 下面我们就逐一击破. 捏柿子就要捡软的捏, 所以我们充分贯彻这一点. 下面先看几个软的.&lt;/p&gt;
&lt;h2 id=&quot;WKWebViewJavascriptBridge&quot;&gt;&lt;a href=&quot;#WKWebViewJavascriptBridge&quot; class=&quot;headerlink&quot; title=&quot;WKWebViewJavascriptBridge&quot;&gt;&lt;/a&gt;WKWebViewJavascriptBridge&lt;/h2&gt;&lt;p&gt;WKWebViewJavascriptBridge 是为了支持 WKWebView 后来新增的, 跟 WebViewJavascriptBridge 应该差不多少, 所以这部分先不用看. &lt;/p&gt;
&lt;h2 id=&quot;WebViewJavascriptBridge-JS&quot;&gt;&lt;a href=&quot;#WebViewJavascriptBridge-JS&quot; class=&quot;headerlink&quot; title=&quot;WebViewJavascriptBridge_JS&quot;&gt;&lt;/a&gt;WebViewJavascriptBridge_JS&lt;/h2&gt;&lt;p&gt;WebViewJavascriptBridge_JS 这个文件是什么呢? 点进去看一下, 发现只有一个返回值是字符串的方法. 比较长, 往下看, 发现都是些 JavaScript 的方法, 是不是就可以大胆的猜测一下, 这个是不是就是传说中的bridge.&lt;/p&gt;
&lt;p&gt;再往下看, 发现&lt;/p&gt;
&lt;figure class=&quot;highlight dts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;window.WebViewJavascriptBridge = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;		registerHandler:&lt;/span&gt; registerHandler,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;		callHandler:&lt;/span&gt; callHandler,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;		_fetchQueue:&lt;/span&gt; _fetchQueue,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;		_handleMessageFromObjC:&lt;/span&gt; _handleMessageFromObjC&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个方法是什么呢? 大概看看应该不难理解, 这个方法就是将全局变量WebViewJavascriptBridge 放在 Web 页面的 JavaScript 中.&lt;/p&gt;
&lt;h2 id=&quot;WebViewJavascriptBridge&quot;&gt;&lt;a href=&quot;#WebViewJavascriptBridge&quot; class=&quot;headerlink&quot; title=&quot;WebViewJavascriptBridge&quot;&gt;&lt;/a&gt;WebViewJavascriptBridge&lt;/h2&gt;&lt;p&gt;1.在初始化时成为 webView 的真实代理&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 实例化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;instancetype&lt;/span&gt;)bridgeForWebView:(WVJB_WEBVIEW_TYPE*)webView &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    WebViewJavascriptBridge* bridge = [[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [bridge _platformSpecificSetup:webView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; bridge;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 成为代理、初始化 WebVeiwJavascriptBridgeBase&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;) _platformSpecificSetup:(WVJB_WEBVIEW_TYPE*)webView &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _webView = webView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _webView.delegate = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _base = [[WebViewJavascriptBridgeBase alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _base.delegate = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 实现 WebViewDelegate 方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;......&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2.暴露接口, 提供 callHandler、registerHandler 方法&lt;/p&gt;
&lt;figure class=&quot;highlight erlang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- &lt;span class=&quot;params&quot;&gt;(void)&lt;/span&gt;registerHandler:&lt;span class=&quot;params&quot;&gt;(NSString*)&lt;/span&gt;handlerName handler:&lt;span class=&quot;params&quot;&gt;(WVJBHandler)&lt;/span&gt;handler;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  - &lt;span class=&quot;params&quot;&gt;(void)&lt;/span&gt;callHandler:&lt;span class=&quot;params&quot;&gt;(NSString*)&lt;/span&gt;handlerName;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  - &lt;span class=&quot;params&quot;&gt;(void)&lt;/span&gt;callHandler:&lt;span class=&quot;params&quot;&gt;(NSString*)&lt;/span&gt;handlerName data:&lt;span class=&quot;params&quot;&gt;(id)&lt;/span&gt;data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  - &lt;span class=&quot;params&quot;&gt;(void)&lt;/span&gt;callHandler:&lt;span class=&quot;params&quot;&gt;(NSString*)&lt;/span&gt;handlerName data:&lt;span class=&quot;params&quot;&gt;(id)&lt;/span&gt;data responseCallback:&lt;span class=&quot;params&quot;&gt;(WVJBResponseCallback)&lt;/span&gt;responseCallback;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 3.监听 Url 变化&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; - (BOOL)&lt;span class=&quot;string&quot;&gt;webView:&lt;/span&gt;(UIWebView *)webView &lt;span class=&quot;string&quot;&gt;shouldStartLoadWithRequest:&lt;/span&gt;(NSURLRequest *)request &lt;span class=&quot;string&quot;&gt;navigationType:&lt;/span&gt;(UIWebViewNavigationType)navigationType &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (webView != _webView) &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; YES; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NSURL *url = [request URL];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  __strong WVJB_WEBVIEW_DELEGATE_TYPE* strongDelegate = _webViewDelegate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([_base &lt;span class=&quot;string&quot;&gt;isCorrectProcotocolScheme:&lt;/span&gt;url]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([_base &lt;span class=&quot;string&quot;&gt;isBridgeLoadedURL:&lt;/span&gt;url]) &amp;#123;&lt;span class=&quot;comment&quot;&gt;// wvjbscheme://__BRIDGE_LOADED__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          [_base injectJavascriptFile]; &lt;span class=&quot;comment&quot;&gt;// 重点：注入JSBridge&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([_base &lt;span class=&quot;string&quot;&gt;isQueueMessageURL:&lt;/span&gt;url]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          NSString *messageQueueString = [self &lt;span class=&quot;string&quot;&gt;_evaluateJavascript:&lt;/span&gt;[_base  webViewJavascriptFetchQueyCommand]]; &lt;span class=&quot;comment&quot;&gt;//从Web 页面获取JS 数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          [_base &lt;span class=&quot;string&quot;&gt;flushMessageQueue:&lt;/span&gt;messageQueueString];  &lt;span class=&quot;comment&quot;&gt;// 数据处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          [_base &lt;span class=&quot;string&quot;&gt;logUnkownMessage:&lt;/span&gt;url];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (strongDelegate &amp;amp;&amp;amp; [strongDelegate &lt;span class=&quot;string&quot;&gt;respondsToSelector:&lt;/span&gt;&lt;span class=&quot;meta&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;webView:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;shouldStartLoadWithRequest:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;navigationType:&lt;/span&gt;)]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [strongDelegate &lt;span class=&quot;string&quot;&gt;webView:&lt;/span&gt;webView &lt;span class=&quot;string&quot;&gt;shouldStartLoadWithRequest:&lt;/span&gt;request &lt;span class=&quot;string&quot;&gt;navigationType:&lt;/span&gt;navigationType];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个类其实就三个作用:&lt;/p&gt;
&lt;p&gt;1.初始化并成为真正的代理&lt;/p&gt;
&lt;p&gt;2.提供接口&lt;/p&gt;
&lt;p&gt;3.监听 url 变化&lt;/p&gt;
&lt;p&gt;而具体实现都是交给 WebViewJavascriptBridgeBase 去完成.&lt;/p&gt;
&lt;h2 id=&quot;WebViewJavascriptBridgeBase&quot;&gt;&lt;a href=&quot;#WebViewJavascriptBridgeBase&quot; class=&quot;headerlink&quot; title=&quot;WebViewJavascriptBridgeBase&quot;&gt;&lt;/a&gt;WebViewJavascriptBridgeBase&lt;/h2&gt;&lt;p&gt;WebViewJavascriptBridgeBase 其实可以看做是 WebViewJavascript 类的业务层, 实现了CallHandler、registerHandler 方法. 通过操控 WebView 执行 JavaScriptString 以及监听 WebView url 变化, 是真正实现 iOS 与 Web 交互的部分.&lt;/p&gt;
&lt;p&gt;1.RegisterHandler&lt;/p&gt;
&lt;figure class=&quot;highlight accesslog&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 将 handlerName 保存起来&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;_base.messageHandlers&lt;span class=&quot;string&quot;&gt;[handlerName]&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;[handler copy]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2.CallHandler&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)sendData:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)data responseCallback:(WVJBResponseCallback)responseCallback handlerName:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt;*)handlerName &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSMutableDictionary&lt;/span&gt;* message = [&lt;span class=&quot;built_in&quot;&gt;NSMutableDictionary&lt;/span&gt; dictionary];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (data) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        message[&lt;span class=&quot;string&quot;&gt;@&quot;data&quot;&lt;/span&gt;] = data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (responseCallback) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt;* callbackId = [&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; stringWithFormat:&lt;span class=&quot;string&quot;&gt;@&quot;objc_cb_%ld&quot;&lt;/span&gt;, ++_uniqueId];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.responseCallbacks[callbackId] = [responseCallback &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        message[&lt;span class=&quot;string&quot;&gt;@&quot;callbackId&quot;&lt;/span&gt;] = callbackId;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (handlerName) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        message[&lt;span class=&quot;string&quot;&gt;@&quot;handlerName&quot;&lt;/span&gt;] = handlerName;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; _queueMessage:message];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要回调时将 responseCallback 按唯一 callbackId 保存 —&amp;gt; message 转 json 字符串 —&amp;gt; WebView 执行 JavaScriptString.&lt;/p&gt;
&lt;p&gt;3.消息处理&lt;/p&gt;
&lt;p&gt;messageQueueString 转JSON, 遍历, 拿到 WVJBMessage 类型的数据. 然后查看是否有responseId, 有则是 iOS 端调 Web 端之后所需要的回调. 没有则就是 Web 主动调 iOS 所发送数据.&lt;/p&gt;
&lt;figure class=&quot;highlight nix&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (responseId) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  WVJBResponseCallback &lt;span class=&quot;attr&quot;&gt;responseCallback&lt;/span&gt; = _responseCallbacks[responseId];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  responseCallback(message[@&lt;span class=&quot;string&quot;&gt;&quot;responseData&quot;&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [self.responseCallbacks removeObjectForKey:responseId];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   WVJBResponseCallback &lt;span class=&quot;attr&quot;&gt;responseCallback&lt;/span&gt; = NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSString* &lt;span class=&quot;attr&quot;&gt;callbackId&lt;/span&gt; = message[@&lt;span class=&quot;string&quot;&gt;&quot;callbackId&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (callbackId) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;attr&quot;&gt;responseCallback&lt;/span&gt; = ^(id responseData) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;attr&quot;&gt;responseData&lt;/span&gt; == nil) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;attr&quot;&gt;responseData&lt;/span&gt; = [NSNull &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       WVJBMessage* &lt;span class=&quot;attr&quot;&gt;msg&lt;/span&gt; = @&amp;#123; @&lt;span class=&quot;string&quot;&gt;&quot;responseId&quot;&lt;/span&gt;:callbackId, @&lt;span class=&quot;string&quot;&gt;&quot;responseData&quot;&lt;/span&gt;:responseData &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [self _queueMessage:msg];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;attr&quot;&gt;responseCallback&lt;/span&gt; = ^(id ignoreResponseData) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             // Do nothing&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/marcuswestin/WebViewJavascriptBridge&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebViewJavascriptBridge&lt;/a&gt;是我们经常会用到的一个Objective-C与JavaScript交互的第三方.&lt;/p&gt;
&lt;p&gt;想想我们如果不用这个第三方是怎么交互的:&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://blog.chusaikeji.com/categories/Objective-C/"/>
    
    
      <category term="读源码" scheme="http://blog.chusaikeji.com/tags/%E8%AF%BB%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Block</title>
    <link href="http://blog.chusaikeji.com/2016/04/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Block/"/>
    <id>http://blog.chusaikeji.com/2016/04/10/深入理解Block/</id>
    <published>2016-04-10T09:37:24.000Z</published>
    <updated>2018-04-30T15:16:54.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8edca89bgw1f2vzgz0qijj20qo0ez0wj.jpg&quot; alt=&quot;来自 Lili Popper 的作品&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Block概要&quot;&gt;&lt;a href=&quot;#Block概要&quot; class=&quot;headerlink&quot; title=&quot;Block概要&quot;&gt;&lt;/a&gt;Block概要&lt;/h3&gt;&lt;h4 id=&quot;什么是Block&quot;&gt;&lt;a href=&quot;#什么是Block&quot; class=&quot;headerlink&quot; title=&quot;什么是Block&quot;&gt;&lt;/a&gt;什么是Block&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Block objects are a C-level syntactic and runtime feature. They are similar to standard C functions, but in addition to executable code they may also contain variable bindings to automatic (stack) or managed (heap) memory. A block can therefore maintain a set of state (data) that it can use to impact behavior when executed.&lt;/p&gt;
&lt;p&gt;怎么理解这段话? 可以分成两段来理解:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Block 对象是一个C语言级别的语法和运行时特征: Block的形式跟C语言中函数指针的形式基本相似(后文会有讲到)&lt;/li&gt;
&lt;li&gt;包含stack或者heap中的内存的变量: Block带有自动变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以, 可以用一句话来表示Block:&lt;strong&gt;带有自动变量(局部变量)的匿名函数&lt;/strong&gt;.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;下面看一个C语言函数的例子&lt;/p&gt;
&lt;figure class=&quot;highlight autoit&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 声明一个名为&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt;的函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(int count)&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 调用这个函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt; result = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 使用函数指针来代替直接调用函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt; result = (* funcptr) (&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;看着似乎不用知道函数名也能够使用该函数,但其实使用函数指针也仍然需要知道函数名称.&lt;/p&gt;
&lt;p&gt;在赋值给函数指针时,若不使用想赋值的函数名称,就无法取得该函数的地址.&lt;br&gt;&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int (&lt;span class=&quot;name&quot;&gt;*&lt;/span&gt; funcptr) (&lt;span class=&quot;name&quot;&gt;int&lt;/span&gt;) = &amp;amp;func&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int result = (&lt;span class=&quot;name&quot;&gt;*funcptr&lt;/span&gt;) (&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;iOS中的Block, 在其他许多程序语言中叫做: 闭包 (Closure)、lambda计算、Anonymous function等.&lt;/p&gt;
&lt;h3 id=&quot;Block模式&quot;&gt;&lt;a href=&quot;#Block模式&quot; class=&quot;headerlink&quot; title=&quot;Block模式&quot;&gt;&lt;/a&gt;Block模式&lt;/h3&gt;&lt;h4 id=&quot;Block表达式语法-Block-Literal-Syntax&quot;&gt;&lt;a href=&quot;#Block表达式语法-Block-Literal-Syntax&quot; class=&quot;headerlink&quot; title=&quot;Block表达式语法 (Block Literal Syntax)&quot;&gt;&lt;/a&gt;Block表达式语法 (Block Literal Syntax)&lt;/h4&gt;&lt;p&gt;基本表达式: &lt;code&gt;^&lt;/code&gt; &lt;code&gt;返回值类型&lt;/code&gt; &lt;code&gt;参数列表&lt;/code&gt; &lt;code&gt;表达式&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最省表达式: &lt;code&gt;^&lt;/code&gt; &lt;code&gt;表达式&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用typedef定义: &lt;code&gt;typedef int (^blk_t) (int);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;死活就是记不住?不要紧,随时可以访问”国际著名Block声明网站”&lt;a href=&quot;http://fuckingblocksyntax.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;How Do I Declare A Block in Objective-C?&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过使用typedef,函数定义就变得更容易理解了.另外,将赋值给Block类型变量中得Block方法像C语言通常的函数调用那样使用,这种方法与使用函数指针类型变量调用函数的方法几乎完全相同.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;变量funcptr为函数指针类型时, 像下面这样调用函数指针类型变量:&lt;br&gt;&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int result = (&lt;span class=&quot;name&quot;&gt;*&lt;/span&gt; funcptr) (&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;变量blk为Block类型的情况下, 这样调用Block类型变量:&lt;br&gt;&lt;figure class=&quot;highlight ebnf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;int result&lt;/span&gt; = bulk(10);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;是不是很相似,这个就是文章开头提到的Block和函数指针.&lt;/p&gt;
&lt;h4 id=&quot;Block类型变量&quot;&gt;&lt;a href=&quot;#Block类型变量&quot; class=&quot;headerlink&quot; title=&quot;Block类型变量&quot;&gt;&lt;/a&gt;Block类型变量&lt;/h4&gt;&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int (^blk) (&lt;span class=&quot;name&quot;&gt;int&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;与前面的使用函数指针的源代码对比可知,声明Block类型变量仅仅是将声明函数指针类型变量的”*”变为”^”.该Block类型变量与一般的C语言变量完全相同, 可作为以下用途使用.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;自动变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数参数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;静态变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;静态全局变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;全局变量&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;截获自动变量值&quot;&gt;&lt;a href=&quot;#截获自动变量值&quot; class=&quot;headerlink&quot; title=&quot;截获自动变量值&quot;&gt;&lt;/a&gt;截获自动变量值&lt;/h4&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; dmy = &lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; val = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *fmt = &lt;span class=&quot;string&quot;&gt;&quot;val = %d\n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (^blk)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;) = ^&amp;#123;&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(fmt, val);&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    val = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt = &lt;span class=&quot;string&quot;&gt;&quot;Test values were changed. val = %d\n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blk ();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行后发现val的值并没有发生变化,这是因为Block表达式保存了自动变量的值,也就是说截获了val和*fmt.&lt;/p&gt;
&lt;h4 id=&quot;block说明符&quot;&gt;&lt;a href=&quot;#block说明符&quot; class=&quot;headerlink&quot; title=&quot;__block说明符&quot;&gt;&lt;/a&gt;__block说明符&lt;/h4&gt;&lt;figure class=&quot;highlight fsharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (^blk) (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;) = ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;blk();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;printf(&lt;span class=&quot;string&quot;&gt;&quot;val = %d\n&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// val = 0;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个地方可以看到,我们在block外面打印了val,但是值并没有改变,那么我们若想在Block语法的表达式中将值赋给在Block语法外声明的自动变量, 需要在该自动变量上附加__block说明符.&lt;/p&gt;
&lt;p&gt;思考思考下面两句话&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;block会截获局部变量,但仅仅是截获,值传递到block内,可以【读】局部变量的值;&lt;/p&gt;
&lt;p&gt;加了 __block 就是用了个结构体进行指针传递，可以【读&lt;strong&gt;&lt;strong&gt; / &lt;/strong&gt;&lt;/strong&gt;写】这个局部变量;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;截获的自动变量&quot;&gt;&lt;a href=&quot;#截获的自动变量&quot; class=&quot;headerlink&quot; title=&quot;截获的自动变量&quot;&gt;&lt;/a&gt;截获的自动变量&lt;/h4&gt;&lt;h3 id=&quot;Block的实现&quot;&gt;&lt;a href=&quot;#Block的实现&quot; class=&quot;headerlink&quot; title=&quot;Block的实现&quot;&gt;&lt;/a&gt;Block的实现&lt;/h3&gt;&lt;h4 id=&quot;Block的实质&quot;&gt;&lt;a href=&quot;#Block的实质&quot; class=&quot;headerlink&quot; title=&quot;Block的实质&quot;&gt;&lt;/a&gt;Block的实质&lt;/h4&gt;&lt;p&gt;用clang(LLVM编译器)将含有Block语法的源代码转换为C++的源代码.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;clang -rewrite-objc 源代码文件名&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int main()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int i = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int &lt;span class=&quot;keyword&quot;&gt;j &lt;/span&gt;= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void (^&lt;span class=&quot;keyword&quot;&gt;blk)(void);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt; &lt;/span&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;blk &lt;/span&gt;= ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        printf(&lt;span class=&quot;string&quot;&gt;&quot;i:%d, j:%d&quot;&lt;/span&gt;, i, &lt;span class=&quot;keyword&quot;&gt;j);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt; &lt;/span&gt;   &amp;#125;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    i = &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;j &lt;/span&gt;= &lt;span class=&quot;number&quot;&gt;2048&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;blk();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __&lt;span class=&quot;title&quot;&gt;Block_byref_i_0&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *__isa;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__Block_byref_i_0 *__forwarding;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; __flags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; __size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __&lt;span class=&quot;title&quot;&gt;main_block_impl_0&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __&lt;span class=&quot;title&quot;&gt;block_impl&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;impl&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __&lt;span class=&quot;title&quot;&gt;main_block_desc_0&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;Desc&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  __main_block_impl_0(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *fp, struct __main_block_desc_0 *desc, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; _i, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; _j, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; flags=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) : i(_i), j(_j) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    impl.isa = &amp;amp;_NSConcreteStackBlock;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    impl.Flags = flags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    impl.FuncPtr = fp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Desc = desc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; __main_block_func_0(struct __main_block_impl_0 *__cself) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = __cself-&amp;gt;i; &lt;span class=&quot;comment&quot;&gt;// bound by copy&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = __cself-&amp;gt;j; &lt;span class=&quot;comment&quot;&gt;// bound by copy&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;i:%d, j:%d&quot;&lt;/span&gt;, i, j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __&lt;span class=&quot;title&quot;&gt;main_block_desc_0&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; reserved;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; Block_size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; __main_block_desc_0_DATA = &amp;#123; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(struct __main_block_impl_0)&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面我们就来分析一下Block结构&lt;/p&gt;
&lt;p&gt;首先是block主题结构体__main_block_impl_0&lt;/p&gt;
&lt;p&gt;第一个成员变量是impl&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __&lt;span class=&quot;title&quot;&gt;block_impl&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *isa;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; Flags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; Reserved;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *FuncPtr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;isa指针说明block是一个objc对象.&lt;/p&gt;
&lt;p&gt;第二个成员变量是Desc指针&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __&lt;span class=&quot;title&quot;&gt;main_block_desc_0&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; reserved;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; Block_size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; __main_block_desc_0_DATA = &amp;#123; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(struct __main_block_impl_0)&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个结构体的构造函数&lt;br&gt;&lt;figure class=&quot;highlight sqf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;__main_block_impl_0&lt;/span&gt;(void *fp, struct &lt;span class=&quot;variable&quot;&gt;__main_block_desc_0&lt;/span&gt; *desc, int &lt;span class=&quot;variable&quot;&gt;_j&lt;/span&gt;, &lt;span class=&quot;variable&quot;&gt;__Block_byref_i_0&lt;/span&gt; *&lt;span class=&quot;variable&quot;&gt;_i&lt;/span&gt;, int flags=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) : j(&lt;span class=&quot;variable&quot;&gt;_j&lt;/span&gt;), i(&lt;span class=&quot;variable&quot;&gt;_i&lt;/span&gt;-&amp;gt;&lt;span class=&quot;variable&quot;&gt;__forwarding&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    impl.isa = &amp;amp;&lt;span class=&quot;variable&quot;&gt;_NSConcreteStackBlock&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    impl.Flags = flags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    impl.FuncPtr = fp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Desc = desc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以上就是一个没有成员变量Block的__main_block_impl_0结构体成员&lt;/p&gt;
&lt;p&gt;其次block执行函数__main_block_func_0&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; __main_block_func_0(struct __main_block_impl_0 *__cself) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = __cself-&amp;gt;i; &lt;span class=&quot;comment&quot;&gt;// bound by copy&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = __cself-&amp;gt;j; &lt;span class=&quot;comment&quot;&gt;// bound by copy&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;i:%d, j:%d&quot;&lt;/span&gt;, i, j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后是block的描述信息结构体__main_block_desc_0&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__main_block_desc_0&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  size_t reserved;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  size_t Block_size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  void (*copy)(&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__main_block_impl_0&lt;/span&gt;&lt;/span&gt;*, &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__main_block_impl_0&lt;/span&gt;&lt;/span&gt;*);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  void (*dispose)(&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__main_block_impl_0&lt;/span&gt;&lt;/span&gt;*);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; __main_block_desc_0_DATA = &amp;#123; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__main_block_impl_0&lt;/span&gt;&lt;/span&gt;), __main_block_copy_0, __main_block_dispose_0&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;截获自动变量值-1&quot;&gt;&lt;a href=&quot;#截获自动变量值-1&quot; class=&quot;headerlink&quot; title=&quot;截获自动变量值&quot;&gt;&lt;/a&gt;截获自动变量值&lt;/h4&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __&lt;span class=&quot;title&quot;&gt;main_block_impl_0&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __&lt;span class=&quot;title&quot;&gt;block_impl&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;impl&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __&lt;span class=&quot;title&quot;&gt;main_block_desc_0&lt;/span&gt;* &lt;span class=&quot;title&quot;&gt;Desc&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  __main_block_impl_0(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *fp, struct __main_block_desc_0 *desc, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; _i, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; _j, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; flags=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) : i(_i), j(_j) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    impl.isa = &amp;amp;_NSConcreteStackBlock;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    impl.Flags = flags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    impl.FuncPtr = fp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Desc = desc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从Block的主体结构可以看到,原本在blcok外部的自动变量 int i 和 int j 被保存到了Block的结构体实例中.此时的j已经不是原来的j了,相当于值拷贝.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;值类型和引用类型的区别&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;block说明符-1&quot;&gt;&lt;a href=&quot;#block说明符-1&quot; class=&quot;headerlink&quot; title=&quot;__block说明符&quot;&gt;&lt;/a&gt;__block说明符&lt;/h4&gt;&lt;p&gt;上面用clang编译的代码是没有用&lt;strong&gt;block修饰的,下面我们来看看加上&lt;/strong&gt;block修饰符后发生了哪些变化&lt;/p&gt;
&lt;p&gt;给变量int i 加上__block修饰符&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int main()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __block int i = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int &lt;span class=&quot;keyword&quot;&gt;j &lt;/span&gt;= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void (^&lt;span class=&quot;keyword&quot;&gt;blk)(void);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt; &lt;/span&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;blk &lt;/span&gt;= ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        printf(&lt;span class=&quot;string&quot;&gt;&quot;i:%d, j:%d&quot;&lt;/span&gt;, i, &lt;span class=&quot;keyword&quot;&gt;j);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt; &lt;/span&gt;   &amp;#125;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    i = &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;j &lt;/span&gt;= &lt;span class=&quot;number&quot;&gt;2048&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;blk();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;用clang编译后的代码&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__Block_byref_i_0&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  void *__isa;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__Block_byref_i_0 *__forwarding;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; int __flags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; int __size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; int i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__main_block_impl_0&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__block_impl&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;impl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__main_block_desc_0&lt;/span&gt;&lt;/span&gt;* Desc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  int j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  __Block_byref_i_0 *i; &lt;span class=&quot;comment&quot;&gt;// by ref&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  __main_block_impl_0(void *fp, &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__main_block_desc_0&lt;/span&gt;&lt;/span&gt; *desc, int _j, __Block_byref_i_0 *_i, int flags=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) : j(_j), i(_i-&amp;gt;__forwarding) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;impl&lt;/span&gt;.isa = &amp;amp;_NSConcreteStackBlock;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;impl&lt;/span&gt;.Flags = flags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;impl&lt;/span&gt;.FuncPtr = fp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Desc = desc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; void __main_block_func_0(&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__main_block_impl_0&lt;/span&gt;&lt;/span&gt; *__cself) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  __Block_byref_i_0 *i = __cself-&amp;gt;i; &lt;span class=&quot;comment&quot;&gt;// bound by ref&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  int j = __cself-&amp;gt;j; &lt;span class=&quot;comment&quot;&gt;// bound by copy&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        printf(&lt;span class=&quot;string&quot;&gt;&quot;i:%d, j:%d&quot;&lt;/span&gt;, (i-&amp;gt;__forwarding-&amp;gt;i), j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; void __main_block_copy_0(&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__main_block_impl_0&lt;/span&gt;&lt;/span&gt;*dst, &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__main_block_impl_0&lt;/span&gt;&lt;/span&gt;*src) &amp;#123;_Block_object_assign((void*)&amp;amp;dst-&amp;gt;i, (void*)src-&amp;gt;i, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;/*BLOCK_FIELD_IS_BYREF*/&lt;/span&gt;);&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; void __main_block_dispose_0(&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__main_block_impl_0&lt;/span&gt;&lt;/span&gt;*src) &amp;#123;_Block_object_dispose((void*)src-&amp;gt;i, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;/*BLOCK_FIELD_IS_BYREF*/&lt;/span&gt;);&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__main_block_desc_0&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  size_t reserved;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  size_t Block_size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  void (*copy)(&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__main_block_impl_0&lt;/span&gt;&lt;/span&gt;*, &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__main_block_impl_0&lt;/span&gt;&lt;/span&gt;*);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  void (*dispose)(&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__main_block_impl_0&lt;/span&gt;&lt;/span&gt;*);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; __main_block_desc_0_DATA = &amp;#123; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__main_block_impl_0&lt;/span&gt;&lt;/span&gt;), __main_block_copy_0, __main_block_dispose_0&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以上下对比一下,只是给变量 int i 加了__block修饰符就多出这么多代码&lt;/p&gt;
&lt;p&gt;全局变量 局部变量&lt;/p&gt;
&lt;p&gt;__block存储域类说明符 ( _block storage-class-specifier)&lt;/p&gt;
&lt;p&gt;__block说明符类似于static、auto和register说明符, 他们用于指定将变量值设置到哪个存储领域中.&lt;/p&gt;
&lt;p&gt;__block修饰的变量val在源码中也会转换为结构体实例&lt;/p&gt;
&lt;figure class=&quot;highlight abnf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct __Block_byref_i_0 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  void *__isa&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__Block_byref_i_0 *__forwarding&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; int __flags&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; int __size&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; int i&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;__block变量也同Block一样变成_Block_byref_val_0结构体类型的自动变量, 即栈上生成的_Block_byref_val_0结构体实例.&lt;/p&gt;
&lt;p&gt;我们发现val这个变量出现在了结构体实例的初始化中,这意味着该结构体持有相当于原自动变量的成员变量.&lt;/p&gt;
&lt;p&gt;_Block_byref_val_0结构体实例的成员变量&lt;strong&gt;forwarding持有指向该实例自身的指针. 通过成员变量&lt;/strong&gt;forwarding访问成员变量val.&lt;/p&gt;
&lt;h4 id=&quot;Block存储域&quot;&gt;&lt;a href=&quot;#Block存储域&quot; class=&quot;headerlink&quot; title=&quot;Block存储域&quot;&gt;&lt;/a&gt;Block存储域&lt;/h4&gt;&lt;p&gt;Block转换为Block的结构体类型的自动变量,&lt;strong&gt;block变量转换为&lt;/strong&gt;block变量的结构体类型的自动变量. 所谓结构体类型的自动变量, 即栈上生成的该结构体的实例.&lt;/p&gt;
&lt;h5 id=&quot;三种类型的Block&quot;&gt;&lt;a href=&quot;#三种类型的Block&quot; class=&quot;headerlink&quot; title=&quot;三种类型的Block:&quot;&gt;&lt;/a&gt;三种类型的Block:&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;NSConcreteStackBlock&lt;/p&gt;
&lt;p&gt;NSConcreteGlobalBlock&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记述全局变量的地方有Block语法时&lt;/li&gt;
&lt;li&gt;Block语法的表达式中不使用应截获的自动变量时&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NSConcreteMallocBlock&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;两个问题&quot;&gt;&lt;a href=&quot;#两个问题&quot; class=&quot;headerlink&quot; title=&quot;两个问题&quot;&gt;&lt;/a&gt;两个问题&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;Block超出变量作用域可存在的原因&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;block变量用结构体成员变量&lt;/strong&gt;forwarding存在的原因&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何解决: 从栈上复制到堆上 (想到定义Block属性的时候为什么用copy了)&lt;/p&gt;
&lt;p&gt;编译器不能判断的状况:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向方法或函数的参数中传递Block时&lt;/li&gt;
&lt;li&gt;Cocoa 框架的方法且方法名中含有usingBlock等时&lt;/li&gt;
&lt;li&gt;Grand Central Dispatch 的 API&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NSArray类的initWithObjects实例方法上传递Block时需要手动复制&lt;/p&gt;
&lt;h4 id=&quot;block变量存储域&quot;&gt;&lt;a href=&quot;#block变量存储域&quot; class=&quot;headerlink&quot; title=&quot;__block变量存储域&quot;&gt;&lt;/a&gt;__block变量存储域&lt;/h4&gt;&lt;h4 id=&quot;截获对象&quot;&gt;&lt;a href=&quot;#截获对象&quot; class=&quot;headerlink&quot; title=&quot;截获对象&quot;&gt;&lt;/a&gt;截获对象&lt;/h4&gt;&lt;p&gt;什么时候栈上的Block会复制到堆上呢?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用Block的copy实例方法时&lt;/li&gt;
&lt;li&gt;Block作为函数返回值返回时&lt;/li&gt;
&lt;li&gt;将Block赋值给附有__strong修饰符id类型的类或Block类型成员变量时&lt;/li&gt;
&lt;li&gt;在方法名中含有usingBlock的Cocoa框架方法或Grand Central Dispatch的API中传递Block时&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;block变量和对象&quot;&gt;&lt;a href=&quot;#block变量和对象&quot; class=&quot;headerlink&quot; title=&quot;__block变量和对象&quot;&gt;&lt;/a&gt;__block变量和对象&lt;/h4&gt;&lt;h4 id=&quot;Block循环引用&quot;&gt;&lt;a href=&quot;#Block循环引用&quot; class=&quot;headerlink&quot; title=&quot;Block循环引用&quot;&gt;&lt;/a&gt;Block循环引用&lt;/h4&gt;&lt;h5 id=&quot;self循环引用&quot;&gt;&lt;a href=&quot;#self循环引用&quot; class=&quot;headerlink&quot; title=&quot;self循环引用&quot;&gt;&lt;/a&gt;self循环引用&lt;/h5&gt;&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self.myblock &lt;/span&gt;= ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;keyword&quot;&gt;self &lt;/span&gt;doSomething]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的这个例子, 就是典型的一个循环引用. self持有myblock, 而myblock又持有self.&lt;/p&gt;
&lt;h5 id=&quot;self隐式循环引用&quot;&gt;&lt;a href=&quot;#self隐式循环引用&quot; class=&quot;headerlink&quot; title=&quot;self隐式循环引用&quot;&gt;&lt;/a&gt;self隐式循环引用&lt;/h5&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; _number;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (^_block)();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewDidLoad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (^_block)() = ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _number = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的例子, 虽然没有出现self,但是同样的会造成循环引用.这也是解决了一些朋友误认为Block的循环引用是跟self有关的误解.&lt;/p&gt;
&lt;p&gt;因为如果在Block中使用附有__strong修饰符的对象类型自动变量, 那么当Block从栈复制到堆时, 该对象为Block所持有.&lt;/p&gt;
&lt;p&gt;所以在用到Block时,推荐大家使用property,不用内部变量.&lt;/p&gt;
&lt;h5 id=&quot;防止循环引用&quot;&gt;&lt;a href=&quot;#防止循环引用&quot; class=&quot;headerlink&quot; title=&quot;防止循环引用&quot;&gt;&lt;/a&gt;防止循环引用&lt;/h5&gt;&lt;p&gt;知道了循环引用产生的原因,就可以对症下药了. 下面三种方式都可以避免循环引用, 但是他们的使用条件和场景不同&lt;/p&gt;
&lt;p&gt;__weak&lt;/p&gt;
&lt;p&gt;__unsafe_unretained&lt;/p&gt;
&lt;p&gt;__block&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;weak本身是可以避免循环引用的问题的,但是其会导致外部对象释放了之后,block内部也访问不到这个对象的问题,我们可以通过在block 内部声明一个&lt;/strong&gt;strong的变量来指向weakObj,使外部对象既能在 block 内部保持住,又能避免循环引用的问题.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;__weak&lt;/span&gt; __typeof(&lt;span class=&quot;keyword&quot;&gt;self)weakSelf &lt;/span&gt;= &lt;span class=&quot;keyword&quot;&gt;self;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;AFNetworkReachabilityStatusBlock &lt;/span&gt;callback = ^(AFNetworkReachabilityStatus status) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __strong __typeof(weakSelf)&lt;span class=&quot;keyword&quot;&gt;strongSelf &lt;/span&gt;= weakSelf&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;strongSelf.networkReachabilityStatus &lt;/span&gt;= status&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;strongSelf.networkReachabilityStatusBlock) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;strongSelf.networkReachabilityStatusBlock(status);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt; &lt;/span&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;AFNetworking中block例子&lt;/p&gt;
&lt;p&gt;常看到一个 block 要使用 self,会处理成在外部声明一个 weak 变量指向 self,在 block 里又声明一个 strong 变量指向 weakSelf:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__weak __typeof(self)weakSelf = self; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.backgroundTaskIdentifier = [application beginBackgroundTaskWithExpirationHandler:^&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __strong __typeof(weakSelf)strongSelf = weakSelf; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;weakSelf是为了block不持有self，避免循环引用，而再声明一个strongSelf是因为一旦进入block执行，就不允许self在这个执行过程中释放。block执行完后这个strongSelf会自动释放，没有循环引用问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;__block避免循环引用时,我们必须在block内部手动把block变量置为nil.否则是无法避免循环引用的.&lt;/p&gt;
&lt;p&gt;使用__block防止循环引用的优缺点:&lt;/p&gt;
&lt;p&gt;优点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过__block变量可控制对象的持有期间&lt;/li&gt;
&lt;li&gt;在不能使用_weak修饰符的环境中不使用_unsafe_unretained修饰符即可&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为避免循环引用必须手动把block变量置为nil&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8edca89bgw1f2vzgz0qijj20qo0ez0wj.jpg&quot; alt=&quot;来自 Lili Popper 的作品&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Block概要&quot;&gt;&lt;a href=&quot;#Block概要&quot; class=&quot;headerlink&quot; title=&quot;Block概要&quot;&gt;&lt;/a&gt;Block概要&lt;/h3&gt;&lt;h4 id=&quot;什么是Block&quot;&gt;&lt;a href=&quot;#什么是Block&quot; class=&quot;headerlink&quot; title=&quot;什么是Block&quot;&gt;&lt;/a&gt;什么是Block&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Block objects are a C-level syntactic and runtime feature. They are similar to standard C functions, but in addition to executable code they may also contain variable bindings to automatic (stack) or managed (heap) memory. A block can therefore maintain a set of state (data) that it can use to impact behavior when executed.&lt;/p&gt;
&lt;p&gt;怎么理解这段话? 可以分成两段来理解:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Block 对象是一个C语言级别的语法和运行时特征: Block的形式跟C语言中函数指针的形式基本相似(后文会有讲到)&lt;/li&gt;
&lt;li&gt;包含stack或者heap中的内存的变量: Block带有自动变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以, 可以用一句话来表示Block:&lt;strong&gt;带有自动变量(局部变量)的匿名函数&lt;/strong&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="Object-C" scheme="http://blog.chusaikeji.com/categories/Object-C/"/>
    
    
      <category term="Block" scheme="http://blog.chusaikeji.com/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 知识点总结</title>
    <link href="http://blog.chusaikeji.com/2016/03/22/HTTP-%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.chusaikeji.com/2016/03/22/HTTP-总结/</id>
    <published>2016-03-22T09:34:00.000Z</published>
    <updated>2018-04-30T14:32:33.000Z</updated>
    
    <content type="html">&lt;p&gt;本文总结了HTTP相关的基础知识,也可算作是《图解HTTP》一书读书笔记,其中图片均来自《图解HTTP》.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;1-了解web及网络基础&quot;&gt;&lt;a href=&quot;#1-了解web及网络基础&quot; class=&quot;headerlink&quot; title=&quot;1. 了解web及网络基础&quot;&gt;&lt;/a&gt;1. 了解web及网络基础&lt;/h2&gt;&lt;h3 id=&quot;1-1-HTTP&quot;&gt;&lt;a href=&quot;#1-1-HTTP&quot; class=&quot;headerlink&quot; title=&quot;1.1 HTTP&quot;&gt;&lt;/a&gt;1.1 HTTP&lt;/h3&gt;&lt;p&gt;HTTP（HyperText Transfer Protocol，超文本传输协议）&lt;/p&gt;
&lt;h3 id=&quot;1-2-TCP-IP协议的各层&quot;&gt;&lt;a href=&quot;#1-2-TCP-IP协议的各层&quot; class=&quot;headerlink&quot; title=&quot;1.2 TCP/IP协议的各层&quot;&gt;&lt;/a&gt;1.2 TCP/IP协议的各层&lt;/h3&gt;&lt;p&gt;1.2.1 协议四层&lt;/p&gt;
&lt;p&gt;应用层&lt;/p&gt;
&lt;p&gt;应用层决定了向用户提供应用服务时通信的活动.TCP/IP协议族内预存了各类通用的应用服务.比如,FTP和DNS服务就是其中两类.HTTP协议也处于该层.&lt;/p&gt;
&lt;p&gt;传输层&lt;/p&gt;
&lt;p&gt;传输层对上层应用层,提供处于网络连接中的两台计算机之间的数据传输.在传输层有两个不同的协议:TCP和UDP.&lt;/p&gt;
&lt;p&gt;网络层&lt;/p&gt;
&lt;p&gt;网络层用来处理在网络上流动的数据包.数据包是网络传输的最小数据单位.该层规定了通过怎样的路径(所谓的传输路线)到达对方计算机,并把数据包传送给对方.与对方计算机之间通过多台计算机或网络设备进行传输时,网络层所起的作用就是众多的选项内选择一条传输路线.&lt;/p&gt;
&lt;p&gt;链路层&lt;/p&gt;
&lt;p&gt;用来处理连接网络的硬件部分.包括控制操作系统、硬件的设备驱动、NIC(Network Interface Card,网络适配器,即网卡),及光纤等物理可见部分(还包括连接器等一切传输媒介).硬件上的范畴均在链路层的作用范围之内.&lt;/p&gt;
&lt;p&gt;1.2.2 封装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-edb043945601030d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-3-与HTTP关系密切的协议：IP、TCP和DNS&quot;&gt;&lt;a href=&quot;#1-3-与HTTP关系密切的协议：IP、TCP和DNS&quot; class=&quot;headerlink&quot; title=&quot;1.3 与HTTP关系密切的协议：IP、TCP和DNS&quot;&gt;&lt;/a&gt;1.3 与HTTP关系密切的协议：IP、TCP和DNS&lt;/h3&gt;&lt;h4 id=&quot;1-3-1-负责传输的IP协议&quot;&gt;&lt;a href=&quot;#1-3-1-负责传输的IP协议&quot; class=&quot;headerlink&quot; title=&quot;1.3.1 负责传输的IP协议&quot;&gt;&lt;/a&gt;1.3.1 负责传输的IP协议&lt;/h4&gt;&lt;p&gt;IP(Internet Protocol)网际协议位于网络层&lt;/p&gt;
&lt;p&gt;IP协议的作用是把各种数据包传送给对方.而要确保传送到对方那里,则需要满足两个重要的条件IP地址和MAC地址.&lt;/p&gt;
&lt;p&gt;IP地址和MAC地址(Media Access Control Address)&lt;/p&gt;
&lt;p&gt;IP地址指明了节点被分配到的地址,MAC地址是指网卡所属的固定地址.&lt;/p&gt;
&lt;p&gt;使用ARP协议(Address Resolution Protocol)凭借MAC地址进行通信.APR是一种用以解析地址的协议,根据通信方的IP地址就可以反查出对应的MAC地址.&lt;/p&gt;
&lt;p&gt;路由选择(routing)&lt;/p&gt;
&lt;h4 id=&quot;1-3-2-确保可靠性的TCP协议&quot;&gt;&lt;a href=&quot;#1-3-2-确保可靠性的TCP协议&quot; class=&quot;headerlink&quot; title=&quot;1.3.2 确保可靠性的TCP协议&quot;&gt;&lt;/a&gt;1.3.2 确保可靠性的TCP协议&lt;/h4&gt;&lt;p&gt;TCP位于传输层,提供可靠的字节流服务.&lt;/p&gt;
&lt;p&gt;三次握手&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-cbe9ecb641aeff4e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;四次挥手&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-94a7ba2a1661a624.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;为什么连接的时候是三次握手，关闭的时候却是四次挥手？&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/9968b16b607e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;为什么连接的时候是三次握手，关闭的时候却是四次挥手？&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-3-3-负责域名解析的DNS服务&quot;&gt;&lt;a href=&quot;#1-3-3-负责域名解析的DNS服务&quot; class=&quot;headerlink&quot; title=&quot;1.3.3 负责域名解析的DNS服务&quot;&gt;&lt;/a&gt;1.3.3 负责域名解析的DNS服务&lt;/h4&gt;&lt;p&gt;DNS(Domain Name System)服务是和HTTP协议一样位于应用层的协议.它提供域名到IP地址之间的解析服务.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-fe1321615fdaeb50.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-4-URI和URL&quot;&gt;&lt;a href=&quot;#1-4-URI和URL&quot; class=&quot;headerlink&quot; title=&quot;1.4 URI和URL&quot;&gt;&lt;/a&gt;1.4 URI和URL&lt;/h3&gt;&lt;p&gt;URI 统一资源标识符&lt;/p&gt;
&lt;p&gt;URL 统一资源定位符&lt;/p&gt;
&lt;h2 id=&quot;2-简单的HTTP协议&quot;&gt;&lt;a href=&quot;#2-简单的HTTP协议&quot; class=&quot;headerlink&quot; title=&quot;2. 简单的HTTP协议&quot;&gt;&lt;/a&gt;2. 简单的HTTP协议&lt;/h2&gt;&lt;p&gt;消息的基本格式:报文&lt;/p&gt;
&lt;p&gt;HTTP协议的请求消息和响应消息的格式及其相似.HTTP消息分为三个部分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首行&lt;/li&gt;
&lt;li&gt;头部（Header）&lt;/li&gt;
&lt;li&gt;正文（Body）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-f2b355234f9a5501.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-159e5109b79eb0db.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-1-无状态协议&quot;&gt;&lt;a href=&quot;#2-1-无状态协议&quot; class=&quot;headerlink&quot; title=&quot;2.1 无状态协议&quot;&gt;&lt;/a&gt;2.1 无状态协议&lt;/h3&gt;&lt;p&gt;HTTP是一种不保存状态,即无状态(stateless)协议.HTTP协议自身不对请求和相应之间的通信状态进行保存.也就是说HTTP这个级别,协议对于发送过的请求或相应都不做持久化处理.&lt;/p&gt;
&lt;h3 id=&quot;2-2-HTTP中可使用的方法&quot;&gt;&lt;a href=&quot;#2-2-HTTP中可使用的方法&quot; class=&quot;headerlink&quot; title=&quot;2.2 HTTP中可使用的方法&quot;&gt;&lt;/a&gt;2.2 HTTP中可使用的方法&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-da1281ea4aed530b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-3-持久连接节省通信量&quot;&gt;&lt;a href=&quot;#2-3-持久连接节省通信量&quot; class=&quot;headerlink&quot; title=&quot;2.3 持久连接节省通信量&quot;&gt;&lt;/a&gt;2.3 持久连接节省通信量&lt;/h3&gt;&lt;p&gt;2.3.1 持久连接&lt;br&gt;2.3.2 管线化&lt;/p&gt;
&lt;h3 id=&quot;2-4-使用cookie的状态管理&quot;&gt;&lt;a href=&quot;#2-4-使用cookie的状态管理&quot; class=&quot;headerlink&quot; title=&quot;2.4 使用cookie的状态管理&quot;&gt;&lt;/a&gt;2.4 使用cookie的状态管理&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-c434764fff3db07b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-HTTP报文内的HTTP信息&quot;&gt;&lt;a href=&quot;#3-HTTP报文内的HTTP信息&quot; class=&quot;headerlink&quot; title=&quot;3. HTTP报文内的HTTP信息&quot;&gt;&lt;/a&gt;3. HTTP报文内的HTTP信息&lt;/h2&gt;&lt;h3 id=&quot;3-1-HTTP报文&quot;&gt;&lt;a href=&quot;#3-1-HTTP报文&quot; class=&quot;headerlink&quot; title=&quot;3.1 HTTP报文&quot;&gt;&lt;/a&gt;3.1 HTTP报文&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-a2b702c9df721a82.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-2-请求报文及响应报文的结构&quot;&gt;&lt;a href=&quot;#3-2-请求报文及响应报文的结构&quot; class=&quot;headerlink&quot; title=&quot;3.2 请求报文及响应报文的结构&quot;&gt;&lt;/a&gt;3.2 请求报文及响应报文的结构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-e5f779ebbaff0f97.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;3-2-1-请求行&quot;&gt;&lt;a href=&quot;#3-2-1-请求行&quot; class=&quot;headerlink&quot; title=&quot;3.2.1 请求行&quot;&gt;&lt;/a&gt;3.2.1 请求行&lt;/h4&gt;&lt;p&gt;包含用于请求的方法,请求URI和HTTP版本.基本格式为:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;方法 路径 版本&lt;/code&gt;&lt;br&gt;例如下面的例子:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GET /simple.html HTTP/1.1&lt;/code&gt;&lt;br&gt;就有对应关系:&lt;/p&gt;
&lt;p&gt;方法：GET&lt;br&gt;路径：/simple.html&lt;br&gt;版本：HTTP/1.1&lt;/p&gt;
&lt;h4 id=&quot;3-2-2响应行-状态行&quot;&gt;&lt;a href=&quot;#3-2-2响应行-状态行&quot; class=&quot;headerlink&quot; title=&quot;3.2.2响应行(状态行)&quot;&gt;&lt;/a&gt;3.2.2响应行(状态行)&lt;/h4&gt;&lt;p&gt;包含表明响应结果的状态码,原因短语和HTTP版本.响应行的基本格式是:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;版本号 状态码 状态文本&lt;/code&gt;&lt;br&gt;例如下面的响应行:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HTTP/1.1 200 OK&lt;/code&gt;&lt;br&gt;其对应关系为：&lt;/p&gt;
&lt;p&gt;版本号：HTTP/1.1&lt;br&gt;状态码：200&lt;br&gt;状态文本：OK&lt;/p&gt;
&lt;h4 id=&quot;3-2-3-首部字段&quot;&gt;&lt;a href=&quot;#3-2-3-首部字段&quot; class=&quot;headerlink&quot; title=&quot;3.2.3 首部字段&quot;&gt;&lt;/a&gt;3.2.3 首部字段&lt;/h4&gt;&lt;p&gt;包含表示请求和相应的各种条件和属性的各类首部.一般有4种首部,分别是:通用首部、请求首部、响应首部和实体首部.&lt;/p&gt;
&lt;p&gt;可参照&lt;a href=&quot;http://tools.jb51.net/table/http_header&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTTP响应头和请求头信息对照表&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-3-编码提升传输效率&quot;&gt;&lt;a href=&quot;#3-3-编码提升传输效率&quot; class=&quot;headerlink&quot; title=&quot;3.3 编码提升传输效率&quot;&gt;&lt;/a&gt;3.3 编码提升传输效率&lt;/h3&gt;&lt;h4 id=&quot;3-3-1-报文主体和实体主体的差异&quot;&gt;&lt;a href=&quot;#3-3-1-报文主体和实体主体的差异&quot; class=&quot;headerlink&quot; title=&quot;3.3.1 报文主体和实体主体的差异&quot;&gt;&lt;/a&gt;3.3.1 报文主体和实体主体的差异&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;报文(message)&lt;br&gt;是HTTP通信中的基本单位,有8位组字节流组成,通过HTTP通信传输.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实体(entity)&lt;br&gt;作为请求或响应的有效载荷数据被传输,其内容有实体首部和实体主体组成.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;3-3-2-压缩传输的内容&quot;&gt;&lt;a href=&quot;#3-3-2-压缩传输的内容&quot; class=&quot;headerlink&quot; title=&quot;3.3.2 压缩传输的内容&quot;&gt;&lt;/a&gt;3.3.2 压缩传输的内容&lt;/h4&gt;&lt;p&gt;gzip (GNU zip)&lt;br&gt;compress (UNIX 系统的压缩标准)&lt;br&gt;deflate (zlib)&lt;br&gt;identifty (不进行编码)&lt;/p&gt;
&lt;h4 id=&quot;3-3-3-分割发送的分块传输编码&quot;&gt;&lt;a href=&quot;#3-3-3-分割发送的分块传输编码&quot; class=&quot;headerlink&quot; title=&quot;3.3.3 分割发送的分块传输编码&quot;&gt;&lt;/a&gt;3.3.3 分割发送的分块传输编码&lt;/h4&gt;&lt;p&gt;在HTTP通信过程中,请求的编码实体资源尚未全部传输完成之前,浏览器无法显示请求页面.在传输大容量数据时,通过把数据分割成多块,能够让浏览器逐步显示页面.&lt;/p&gt;
&lt;p&gt;这种把实体主体分块的功能称为分块传输编码(Chunked Transfer Coding).&lt;/p&gt;
&lt;h3 id=&quot;3-4-发送多种数据的多部分对象集合&quot;&gt;&lt;a href=&quot;#3-4-发送多种数据的多部分对象集合&quot; class=&quot;headerlink&quot; title=&quot;3.4 发送多种数据的多部分对象集合&quot;&gt;&lt;/a&gt;3.4 发送多种数据的多部分对象集合&lt;/h3&gt;&lt;p&gt;MIME(Multipurpose Internet Mail Extensions,多用途英特网邮件扩展)&lt;/p&gt;
&lt;p&gt;Content-type&lt;/p&gt;
&lt;p&gt;获取部分内容的范围请求&lt;/p&gt;
&lt;p&gt;Range Request&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-8a614380020cf24c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-5-内容协商返回最合适&quot;&gt;&lt;a href=&quot;#3-5-内容协商返回最合适&quot; class=&quot;headerlink&quot; title=&quot;3.5 内容协商返回最合适&quot;&gt;&lt;/a&gt;3.5 内容协商返回最合适&lt;/h3&gt;&lt;h2 id=&quot;4-返回结果的HTTP状态码&quot;&gt;&lt;a href=&quot;#4-返回结果的HTTP状态码&quot; class=&quot;headerlink&quot; title=&quot;4. 返回结果的HTTP状态码&quot;&gt;&lt;/a&gt;4. 返回结果的HTTP状态码&lt;/h2&gt;&lt;p&gt;1XX：Informational（信息性状态码），表明接受的请求正在处理。&lt;br&gt;2XX：Success（成功状态码），表明请求正常处理完毕。&lt;br&gt;3XX：Redirection（重定向状态码），表明需进行附加操作以完成请求。&lt;br&gt;4XX：Client Error（客户端错误状态码），表明服务器无法处理请求。&lt;br&gt;5XX：Server Error（服务器错误状态码），表明服务器处理请求出错。&lt;/p&gt;
&lt;p&gt;200 OK&lt;br&gt;204 No Content&lt;br&gt;206 Partial Content&lt;/p&gt;
&lt;p&gt;301 Moved Permanently&lt;br&gt;302 Found&lt;br&gt;303 See Other&lt;br&gt;304 Not Modified&lt;br&gt;307 Temporary Redirect&lt;/p&gt;
&lt;p&gt;400 Bad Request&lt;br&gt;401 Unauthorized&lt;br&gt;403 Forbidden&lt;br&gt;404 Not Found&lt;/p&gt;
&lt;p&gt;500 Internal Server Error&lt;br&gt;503 Service Unavailable&lt;/p&gt;
&lt;p&gt;忘记的话可以查看&lt;a href=&quot;http://www.w3school.com.cn/tags/html_ref_httpmessages.asp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTTP 状态码大全&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-与HTTP协作的web服务器&quot;&gt;&lt;a href=&quot;#5-与HTTP协作的web服务器&quot; class=&quot;headerlink&quot; title=&quot;5. 与HTTP协作的web服务器&quot;&gt;&lt;/a&gt;5. 与HTTP协作的web服务器&lt;/h2&gt;&lt;h3 id=&quot;5-1-用单台虚拟主机实现多个域名&quot;&gt;&lt;a href=&quot;#5-1-用单台虚拟主机实现多个域名&quot; class=&quot;headerlink&quot; title=&quot;5.1 用单台虚拟主机实现多个域名&quot;&gt;&lt;/a&gt;5.1 用单台虚拟主机实现多个域名&lt;/h3&gt;&lt;h3 id=&quot;5-2-通信数据转发程序：代理、网关、隧道1&quot;&gt;&lt;a href=&quot;#5-2-通信数据转发程序：代理、网关、隧道1&quot; class=&quot;headerlink&quot; title=&quot;5.2 通信数据转发程序：代理、网关、隧道1&quot;&gt;&lt;/a&gt;5.2 通信数据转发程序：代理、网关、隧道1&lt;/h3&gt;&lt;h4 id=&quot;5-2-1-代理&quot;&gt;&lt;a href=&quot;#5-2-1-代理&quot; class=&quot;headerlink&quot; title=&quot;5.2.1 代理&quot;&gt;&lt;/a&gt;5.2.1 代理&lt;/h4&gt;&lt;p&gt;代理可按是否使用缓存和是否修改报文分类&lt;/p&gt;
&lt;p&gt;5.2.1.1 缓存代理（CachingProxy）&lt;/p&gt;
&lt;p&gt;转发响应时，会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接受到相同请求时，可以不从原服务器获取资源，直接从缓存返回。&lt;/p&gt;
&lt;p&gt;5.2.1.2 透明代理（TransparentProxy）/非透明代理&lt;/p&gt;
&lt;p&gt;转发或响应请求时不对报文加工的叫透明代理，反之为非透明代理。&lt;/p&gt;
&lt;h4 id=&quot;5-2-2-网关&quot;&gt;&lt;a href=&quot;#5-2-2-网关&quot; class=&quot;headerlink&quot; title=&quot;5.2.2 网关&quot;&gt;&lt;/a&gt;5.2.2 网关&lt;/h4&gt;&lt;p&gt;网关是转发其他服务器通信数据的服务器，接收从客户端发来的请求时，他就像自己拥有资源的源服务器一样对请求进行处理。&lt;/p&gt;
&lt;p&gt;网关和代理的区别是网关能使通信线路上的服务器提供非HTTP协议服务。利用网关能提高通信的安全性，因为可以在客户端和网关线路上加密以确保链接的安全。&lt;/p&gt;
&lt;h4 id=&quot;5-2-3-隧道&quot;&gt;&lt;a href=&quot;#5-2-3-隧道&quot; class=&quot;headerlink&quot; title=&quot;5.2.3 隧道&quot;&gt;&lt;/a&gt;5.2.3 隧道&lt;/h4&gt;&lt;p&gt;隧道是在相隔甚远的客户端和服务器两者之间中转，并保存双方通信连接的应用程序。可使用SSL等手段加密。隧道本身不解析HTTP请求。&lt;/p&gt;
&lt;h3 id=&quot;5-3-保存资源的缓存&quot;&gt;&lt;a href=&quot;#5-3-保存资源的缓存&quot; class=&quot;headerlink&quot; title=&quot;5.3 保存资源的缓存&quot;&gt;&lt;/a&gt;5.3 保存资源的缓存&lt;/h3&gt;&lt;h4 id=&quot;5-2-1-缓存的有效期限&quot;&gt;&lt;a href=&quot;#5-2-1-缓存的有效期限&quot; class=&quot;headerlink&quot; title=&quot;5.2.1 缓存的有效期限&quot;&gt;&lt;/a&gt;5.2.1 缓存的有效期限&lt;/h4&gt;&lt;h4 id=&quot;5-2-2-客户端的缓存&quot;&gt;&lt;a href=&quot;#5-2-2-客户端的缓存&quot; class=&quot;headerlink&quot; title=&quot;5.2.2 客户端的缓存&quot;&gt;&lt;/a&gt;5.2.2 客户端的缓存&lt;/h4&gt;&lt;p&gt;缓存指代理服务器或客户端本地磁盘保存的资源副本。利用缓存可以减少对源服务器的访问，也节省了通信流量和通信时间。&lt;/p&gt;
&lt;p&gt;cookie&lt;/p&gt;
&lt;p&gt;可以笼统的将cookie分为两类：会话cookie和持久cookie&lt;/p&gt;
&lt;p&gt;会话cookie是一种临时cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话cookie就被删除了。&lt;/p&gt;
&lt;p&gt;持久cookie的生存时间更长一些，他们存储在磁盘上，浏览器退出，计算机重启时它们仍然存在。&lt;/p&gt;
&lt;p&gt;会话cookie和持久cookie之间唯一的区别就是它们的过期时间。&lt;/p&gt;
&lt;p&gt;稍后我们会看到，如果设置了Discard参数，或者没有设置Expires或Max-Age参数来说明扩展的过期时间，这个cookie就是一个会话cookie。&lt;/p&gt;
&lt;h2 id=&quot;6-HTTP首部&quot;&gt;&lt;a href=&quot;#6-HTTP首部&quot; class=&quot;headerlink&quot; title=&quot;6. HTTP首部&quot;&gt;&lt;/a&gt;6. HTTP首部&lt;/h2&gt;&lt;h3 id=&quot;6-1-HTTP报文首部&quot;&gt;&lt;a href=&quot;#6-1-HTTP报文首部&quot; class=&quot;headerlink&quot; title=&quot;6.1 HTTP报文首部&quot;&gt;&lt;/a&gt;6.1 HTTP报文首部&lt;/h3&gt;&lt;h3 id=&quot;6-2-HTTP首部字段&quot;&gt;&lt;a href=&quot;#6-2-HTTP首部字段&quot; class=&quot;headerlink&quot; title=&quot;6.2 HTTP首部字段&quot;&gt;&lt;/a&gt;6.2 HTTP首部字段&lt;/h3&gt;&lt;p&gt;通用首部字段&lt;/p&gt;
&lt;p&gt;请求首部字段&lt;/p&gt;
&lt;p&gt;响应首部字段&lt;/p&gt;
&lt;p&gt;实体首部字段&lt;/p&gt;
&lt;p&gt;为cookie服务的首部字段&lt;/p&gt;
&lt;h2 id=&quot;7-确保web安全的HTTPS&quot;&gt;&lt;a href=&quot;#7-确保web安全的HTTPS&quot; class=&quot;headerlink&quot; title=&quot;7. 确保web安全的HTTPS&quot;&gt;&lt;/a&gt;7. 确保web安全的HTTPS&lt;/h2&gt;&lt;h3 id=&quot;7-1-HTTP的缺点&quot;&gt;&lt;a href=&quot;#7-1-HTTP的缺点&quot; class=&quot;headerlink&quot; title=&quot;7.1 HTTP的缺点&quot;&gt;&lt;/a&gt;7.1 HTTP的缺点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;通信使用明文（不加密），内容可能会被窃听&lt;/li&gt;
&lt;li&gt;不验证通信方的身份，因此有可能遭遇伪装&lt;/li&gt;
&lt;li&gt;无法证明报文的完整性，所以有可能已遭篡改&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;7-1-1-加密处理防止被窃听&quot;&gt;&lt;a href=&quot;#7-1-1-加密处理防止被窃听&quot; class=&quot;headerlink&quot; title=&quot;7.1.1 加密处理防止被窃听&quot;&gt;&lt;/a&gt;7.1.1 加密处理防止被窃听&lt;/h4&gt;&lt;p&gt;7.1.2.1 通信的加密&lt;/p&gt;
&lt;p&gt;HTTPS加密处理防止窃听: 可通过SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全传输协议）的组合使用，加密通信。与SSL组合使用的HTTP叫HTTPS。&lt;/p&gt;
&lt;p&gt;7.1.2.2 内容加密&lt;/p&gt;
&lt;p&gt;对 HTTP 协议传输的内容本身加密。即把HTTP报文里所含的内容进行加密处理。&lt;/p&gt;
&lt;h4 id=&quot;7-1-2-不验证通信方的身份-可能遭遇伪装&quot;&gt;&lt;a href=&quot;#7-1-2-不验证通信方的身份-可能遭遇伪装&quot; class=&quot;headerlink&quot; title=&quot;7.1.2 不验证通信方的身份,可能遭遇伪装&quot;&gt;&lt;/a&gt;7.1.2 不验证通信方的身份,可能遭遇伪装&lt;/h4&gt;&lt;p&gt;HTTP弱的地方在于：请求有可能去到已伪装的服务器、已伪装的客户端；无法确定对方是否有访问权限；无意义的请求也照单全收，无法阻止海量请求下的DoS攻击（Denial of Service, 拒绝服务攻击）&lt;/p&gt;
&lt;p&gt;解决方案：密钥、证书&lt;/p&gt;
&lt;h4 id=&quot;7-1-3-无法证明报文的完整性，可能已遭篡改&quot;&gt;&lt;a href=&quot;#7-1-3-无法证明报文的完整性，可能已遭篡改&quot; class=&quot;headerlink&quot; title=&quot;7.1.3 无法证明报文的完整性，可能已遭篡改&quot;&gt;&lt;/a&gt;7.1.3 无法证明报文的完整性，可能已遭篡改&lt;/h4&gt;&lt;p&gt;由于 HTTP 协议无法证明通信的报文完整性,在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。&lt;/p&gt;
&lt;p&gt;请求或响应在传输图中遭遇攻击者拦截篡改，叫中间人攻击（Man-in-the-Middle Attack）.&lt;/p&gt;
&lt;h3 id=&quot;7-2-HTTP-加密-认证-完整性保护-HTTPS&quot;&gt;&lt;a href=&quot;#7-2-HTTP-加密-认证-完整性保护-HTTPS&quot; class=&quot;headerlink&quot; title=&quot;7.2 HTTP+加密+认证+完整性保护=HTTPS&quot;&gt;&lt;/a&gt;7.2 HTTP+加密+认证+完整性保护=HTTPS&lt;/h3&gt;&lt;h4 id=&quot;7-2-1-所谓-HTTPS，其实就是身披-SSL-协议这层外壳的-HTTP&quot;&gt;&lt;a href=&quot;#7-2-1-所谓-HTTPS，其实就是身披-SSL-协议这层外壳的-HTTP&quot; class=&quot;headerlink&quot; title=&quot;7.2.1 所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP&quot;&gt;&lt;/a&gt;7.2.1 所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP&lt;/h4&gt;&lt;p&gt;HTTPS连接建立过程大致是，客户端和服务端建立一个连接，服务端返回一个证书，客户端里存有各个受信任的证书机构根证书，用这些根证书对服务端返回的证书进行验证，经验证如果证书是可信任的，就生成一个pre-master  secret，用这个证书的公钥加密后发送给服务端，服务端用私钥解密后得到pre-master secret，再根据某种算法生成master  secret，客户端也同样根据这种算法从pre-master secret生成master secret，随后双方的通信都用这个master  secret对传输数据进行加密解密。&lt;/p&gt;
&lt;h4 id=&quot;7-2-2-使用两把密钥的公开密钥加密&quot;&gt;&lt;a href=&quot;#7-2-2-使用两把密钥的公开密钥加密&quot; class=&quot;headerlink&quot; title=&quot;7.2.2 使用两把密钥的公开密钥加密&quot;&gt;&lt;/a&gt;7.2.2 使用两把密钥的公开密钥加密&lt;/h4&gt;&lt;p&gt;公开密钥加密使用一对非对称的密钥.一把叫做私有密钥(private key),另一把叫做公开密钥(public key).顾名思义,私有密钥不能让其他任何人知道,而公开密钥则可以随意发布,任何人都可以获得.使用公开密钥加密方式,发送密文的一方使用对方的公开密钥进行加密处理,对方收到被加密的信息后,再使用自己的私有密钥进行解密.利用这种方式,不需要发送用来解密的私有密钥,也不必担心密钥被攻击者窃听而盗走.&lt;/p&gt;
&lt;h4 id=&quot;7-2-3-证明公开密钥正确性的证书&quot;&gt;&lt;a href=&quot;#7-2-3-证明公开密钥正确性的证书&quot; class=&quot;headerlink&quot; title=&quot;7.2.3 证明公开密钥正确性的证书&quot;&gt;&lt;/a&gt;7.2.3 证明公开密钥正确性的证书&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-57c2cb4eeb07f6d2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;7-2-4-HTTPS的安全通信机制&quot;&gt;&lt;a href=&quot;#7-2-4-HTTPS的安全通信机制&quot; class=&quot;headerlink&quot; title=&quot;7.2.4 HTTPS的安全通信机制&quot;&gt;&lt;/a&gt;7.2.4 HTTPS的安全通信机制&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-4f23cda66b7bb579.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么不一直使用 HTTPS&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为与纯文本通信相比，加密通信会消耗更多的CPU及内存资源。&lt;/li&gt;
&lt;li&gt;节约购买证书的开销&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;8-确认访问用户身份的认证&quot;&gt;&lt;a href=&quot;#8-确认访问用户身份的认证&quot; class=&quot;headerlink&quot; title=&quot;8. 确认访问用户身份的认证&quot;&gt;&lt;/a&gt;8. 确认访问用户身份的认证&lt;/h2&gt;&lt;p&gt;8.1 BASIC&lt;/p&gt;
&lt;p&gt;8.2 DIGEST&lt;/p&gt;
&lt;p&gt;8.3 SSL客户端认证&lt;/p&gt;
&lt;p&gt;8.4 基于表单认证&lt;/p&gt;
&lt;h2 id=&quot;9-基于HTTP的功能追加协议&quot;&gt;&lt;a href=&quot;#9-基于HTTP的功能追加协议&quot; class=&quot;headerlink&quot; title=&quot;9. 基于HTTP的功能追加协议&quot;&gt;&lt;/a&gt;9. 基于HTTP的功能追加协议&lt;/h2&gt;&lt;h3 id=&quot;9-1-HTTP瓶颈&quot;&gt;&lt;a href=&quot;#9-1-HTTP瓶颈&quot; class=&quot;headerlink&quot; title=&quot;9.1 HTTP瓶颈&quot;&gt;&lt;/a&gt;9.1 HTTP瓶颈&lt;/h3&gt;&lt;h4 id=&quot;9-1-1-HTTP的性能瓶颈&quot;&gt;&lt;a href=&quot;#9-1-1-HTTP的性能瓶颈&quot; class=&quot;headerlink&quot; title=&quot;9.1.1 HTTP的性能瓶颈&quot;&gt;&lt;/a&gt;9.1.1 HTTP的性能瓶颈&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;一条连接上只可发送一个请求&lt;/li&gt;
&lt;li&gt;请求只能从客户端开始.客户端不可接受除响应以外的指令&lt;/li&gt;
&lt;li&gt;请求/响应首部未经压缩就发送.首部信息越多延迟越大&lt;/li&gt;
&lt;li&gt;发送冗长的首部,每次互相发送相同的首部造成的浪费较多&lt;/li&gt;
&lt;li&gt;有时不压缩数据直接发送&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;9-1-2-解决方法HTTP的追加协议&quot;&gt;&lt;a href=&quot;#9-1-2-解决方法HTTP的追加协议&quot; class=&quot;headerlink&quot; title=&quot;9.1.2 解决方法HTTP的追加协议&quot;&gt;&lt;/a&gt;9.1.2 解决方法HTTP的追加协议&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Ajax &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Comet&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SPDY协议&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;9-2-使用浏览器进行全双工通信的WebSocket&quot;&gt;&lt;a href=&quot;#9-2-使用浏览器进行全双工通信的WebSocket&quot; class=&quot;headerlink&quot; title=&quot;9.2 使用浏览器进行全双工通信的WebSocket&quot;&gt;&lt;/a&gt;9.2 使用浏览器进行全双工通信的WebSocket&lt;/h3&gt;&lt;h4 id=&quot;HTTP、Socket、TCP的区别&quot;&gt;&lt;a href=&quot;#HTTP、Socket、TCP的区别&quot; class=&quot;headerlink&quot; title=&quot;HTTP、Socket、TCP的区别&quot;&gt;&lt;/a&gt;HTTP、Socket、TCP的区别&lt;/h4&gt;&lt;p&gt;Socket 是应用层与TCP/IP协议族通信的中间软件抽象层,它是一组接口.通过下图可以看到Socket的位置.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-4cbc2c22347fa8cd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;1.TCP连接与HTTP连接的区别&lt;/p&gt;
&lt;p&gt;HTTP基于TCP&lt;/p&gt;
&lt;p&gt;2.TCP连接与Socket连接的区别&lt;/p&gt;
&lt;p&gt;Socket基于TCP&lt;/p&gt;
&lt;p&gt;Socket层其实是在TCP/UDP传输层上做的一个抽象接口层,因此一个Socket连接可以基于TCP,也有可能基于UDP.&lt;/p&gt;
&lt;p&gt;基于TCP协议的Socket连接同样需要通过三次握手建立连接,是可靠的;&lt;/p&gt;
&lt;p&gt;基于UDP协议的Socket连接不需要建立连接的过程,但是是不可靠的.&lt;/p&gt;
&lt;p&gt;3.HTTP连接与Socket连接的区别&lt;/p&gt;
&lt;p&gt;HTTP是短连接,Socket(基于TCP协议的)是长连接。尽管HTTP1.1开始支持持久连接,但仍无法保证始终连接.而Socket连接一旦建立连接(TCP三次握手),除非一方主动断开,否则连接状态一直保持.&lt;/p&gt;
&lt;p&gt;HTTP连接服务端无法主动发消息,HTTP连接使用的是“请求—响应”的方式,不仅在请求时需要先建立连接,而且需要客户端向服务器发出请求后,服务器端才能回复数据.&lt;/p&gt;
&lt;p&gt;很多情况下,需要服务器端主动向客户端推送数据,保持客户端与服务器数据的实时与同步.Socket连接后,一方随时可以向另一方喊话.&lt;/p&gt;
&lt;h2 id=&quot;10-构建web内容的技术&quot;&gt;&lt;a href=&quot;#10-构建web内容的技术&quot; class=&quot;headerlink&quot; title=&quot;10. 构建web内容的技术&quot;&gt;&lt;/a&gt;10. 构建web内容的技术&lt;/h2&gt;&lt;h3 id=&quot;10-1-HTML&quot;&gt;&lt;a href=&quot;#10-1-HTML&quot; class=&quot;headerlink&quot; title=&quot;10.1 HTML&quot;&gt;&lt;/a&gt;10.1 HTML&lt;/h3&gt;&lt;h3 id=&quot;10-2-动态HTML&quot;&gt;&lt;a href=&quot;#10-2-动态HTML&quot; class=&quot;headerlink&quot; title=&quot;10.2 动态HTML&quot;&gt;&lt;/a&gt;10.2 动态HTML&lt;/h3&gt;&lt;p&gt;JavaScript&lt;/p&gt;
&lt;h3 id=&quot;10-3-WEB应用相关&quot;&gt;&lt;a href=&quot;#10-3-WEB应用相关&quot; class=&quot;headerlink&quot; title=&quot;10.3 WEB应用相关&quot;&gt;&lt;/a&gt;10.3 WEB应用相关&lt;/h3&gt;&lt;p&gt;10.3.1 与WEB服务器及程序协作的CGI&lt;/p&gt;
&lt;p&gt;10.3.2 因Java而普及的Servlet&lt;/p&gt;
&lt;h3 id=&quot;10-4-数据发布的格式及语言&quot;&gt;&lt;a href=&quot;#10-4-数据发布的格式及语言&quot; class=&quot;headerlink&quot; title=&quot;10.4 数据发布的格式及语言&quot;&gt;&lt;/a&gt;10.4 数据发布的格式及语言&lt;/h3&gt;&lt;h2 id=&quot;11-web的攻击技术&quot;&gt;&lt;a href=&quot;#11-web的攻击技术&quot; class=&quot;headerlink&quot; title=&quot;11. web的攻击技术&quot;&gt;&lt;/a&gt;11. web的攻击技术&lt;/h2&gt;&lt;h3 id=&quot;11-1-针对Web的攻击技术&quot;&gt;&lt;a href=&quot;#11-1-针对Web的攻击技术&quot; class=&quot;headerlink&quot; title=&quot;11.1 针对Web的攻击技术&quot;&gt;&lt;/a&gt;11.1 针对Web的攻击技术&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;主动攻击&lt;/li&gt;
&lt;li&gt;被动攻击&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;11-2-因输出值转义不完全引发的安全漏洞&quot;&gt;&lt;a href=&quot;#11-2-因输出值转义不完全引发的安全漏洞&quot; class=&quot;headerlink&quot; title=&quot;11.2 因输出值转义不完全引发的安全漏洞&quot;&gt;&lt;/a&gt;11.2 因输出值转义不完全引发的安全漏洞&lt;/h3&gt;&lt;p&gt;11.2.1 跨站脚本攻击&lt;/p&gt;
&lt;p&gt;Cross-Site Scripting, XSS&lt;/p&gt;
&lt;p&gt;11.2.2 SQL 注入攻击&lt;br&gt;11.2.3 OS 命令注入攻击&lt;br&gt;11.2.4 HTTP首部注入攻击&lt;br&gt;11.2.5 邮件首部注入攻击&lt;br&gt;11.2.6 目录遍历攻击&lt;br&gt;11.2.7 远程文件包含漏洞&lt;/p&gt;
&lt;h3 id=&quot;11-3-因设置或设计上的缺陷引发的安全漏洞&quot;&gt;&lt;a href=&quot;#11-3-因设置或设计上的缺陷引发的安全漏洞&quot; class=&quot;headerlink&quot; title=&quot;11.3 因设置或设计上的缺陷引发的安全漏洞&quot;&gt;&lt;/a&gt;11.3 因设置或设计上的缺陷引发的安全漏洞&lt;/h3&gt;&lt;h3 id=&quot;11-4-因会话管理疏忽引发的安全漏洞&quot;&gt;&lt;a href=&quot;#11-4-因会话管理疏忽引发的安全漏洞&quot; class=&quot;headerlink&quot; title=&quot;11.4 因会话管理疏忽引发的安全漏洞&quot;&gt;&lt;/a&gt;11.4 因会话管理疏忽引发的安全漏洞&lt;/h3&gt;&lt;p&gt;11.4.1 会话劫持&lt;br&gt;11.4.2 会话固定攻击&lt;br&gt;11.4.3 跨站点请求伪造&lt;/p&gt;
&lt;h3 id=&quot;11-5-其他安全漏洞&quot;&gt;&lt;a href=&quot;#11-5-其他安全漏洞&quot; class=&quot;headerlink&quot; title=&quot;11.5 其他安全漏洞&quot;&gt;&lt;/a&gt;11.5 其他安全漏洞&lt;/h3&gt;&lt;p&gt;11.5.1 密码破解&lt;br&gt;11.5.2 Dos攻击&lt;br&gt;11.5.3 后门程序&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文总结了HTTP相关的基础知识,也可算作是《图解HTTP》一书读书笔记,其中图片均来自《图解HTTP》.&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://blog.chusaikeji.com/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="http://blog.chusaikeji.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 时间编程</title>
    <link href="http://blog.chusaikeji.com/2016/03/16/iOS-%E6%97%B6%E9%97%B4%E7%BC%96%E7%A8%8B/"/>
    <id>http://blog.chusaikeji.com/2016/03/16/iOS-时间编程/</id>
    <published>2016-03-16T08:06:00.000Z</published>
    <updated>2018-04-30T15:09:20.000Z</updated>
    
    <content type="html">&lt;p&gt;时间编程是我们在开发中经常要遇到,比如说时间戳的转换,根据日期更新数据,是否清除一周缓存,时间间隔计算等等,而这些点又比较零散,不容易系统的掌握iOS时间编程.此文就是通过一些经常要用到的方法作为例子,从上到下,系统的对时间编程总结.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;首先,从总体上把握一下跟时间编程有关的类&lt;/p&gt;
&lt;p&gt;NSDate&lt;br&gt;NSDateFormatter&lt;br&gt;NSDateComponents&lt;br&gt;NSDateComponentFormatter&lt;br&gt;NSCalendar&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-21f3ef0f32f35910.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://edsioon.me/about-nsdate/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图片来自@EDSIOON&lt;/a&gt;包含了iOS时间编程的所有类,能看懂这个图基本上说明你已经掌握了时间编程.&lt;/p&gt;
&lt;p&gt;上图可以从&lt;code&gt;NSDate&lt;/code&gt;分成左右两边来看,你会发现无论从哪一点走都能走通,如果只有右边的话也是没有问题的.那么左边的NSCalendar是什么? NSCalendar是时间编程中的日历体系,它结合NSDateComponents把时间分解为方便我们管理的组件,使我们更直观更容易处理时间.在后面的一些例子中还会做进一步说明.&lt;/p&gt;
&lt;h2 id=&quot;NSDate和字符串相互转换&quot;&gt;&lt;a href=&quot;#NSDate和字符串相互转换&quot; class=&quot;headerlink&quot; title=&quot;NSDate和字符串相互转换&quot;&gt;&lt;/a&gt;NSDate和字符串相互转换&lt;/h2&gt;&lt;p&gt;NSDate对象是对一个简单时间点的封装,表示公历的GMT时间(格林威治时间),其实就是表示距离特定参考时间点(2001-01-01 GMT)已过去的秒数.它不但用于日期,也用于时间处理.&lt;/p&gt;
&lt;p&gt;NSDate和字符串相互转换时,我们要用到格式化的概念,既NSDateFormatter类.NSDateFormatter是NSFormatter的子类,NSFormatter的用途是将数据在字符串与特定类型的对象之间转换.那么在NSDate和字符串相互转换时,要根据需求设置相对应的格式.&lt;/p&gt;
&lt;p&gt;使用date formatter style格式化输出字符串&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSDate *currentDate = [NSDate date];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dateFormatter.locale = [NSLocale currentLocale];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dateFormatter.dateStyle = kCFDateFormatterFullStyle;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString *convertedDate = [dateFormatter stringFromDate:currentDate];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;%@&amp;quot;, convertedDate);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;Monday, February 1, 2016&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;dateFormatter有两种方式可以设置格式:一种是通过一些系统预定义的日期格式化样式(style);另外一种是通过某些说明符来手动设置日期格式,也就是由开发者自定义格式。上面我们用到的就是系统自带的格式化样式.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用日期格式说明符&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EEEE：“星期”的全名（比如Monday）。如需缩写，指定1-3个字符（如E，EE，EEE代表Mon）。&lt;/li&gt;
&lt;li&gt;MMMM：“月份”的全名（比如October）。如需缩写，指定1-3个字符（如M，MM，MMM代表Oct）。&lt;/li&gt;
&lt;li&gt;dd：某月的第几天（例如，09或15）&lt;/li&gt;
&lt;li&gt;yyyy：四位字符串表示“年”（例如2015）&lt;/li&gt;
&lt;li&gt;HH：两位字符串表示“小时”（例如08或19）&lt;/li&gt;
&lt;li&gt;mm：两位字符串表示“分钟”（例如05或54）&lt;/li&gt;
&lt;li&gt;ss：两位字符串表示“秒”&lt;/li&gt;
&lt;li&gt;zzz：三位字符串表示“时区”（例如GMT）&lt;/li&gt;
&lt;li&gt;GGG：公元前BC或公元后AD&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dateFormatter.dateFormat = @&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;2016-02-01 15:54:43&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Converting from String to NSDate&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString *dateString = @&amp;quot;2016-02-01 15:54:43&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dateFormatter.dateFormat = @&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSDate *newDate = [dateFormatter dateFromString:dateString];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;%@&amp;quot;, newDate);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;2016-02-01 07:54:43 +0000&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 过多使用NSDateFormatter将影响程序的性能,且程序中NSDateFormatter对象的时间格式基本一致,所以使用NSDateFormatter的时候尽量使用单例模式.&lt;/p&gt;
&lt;h2 id=&quot;时间戳和日期的相互转化&quot;&gt;&lt;a href=&quot;#时间戳和日期的相互转化&quot; class=&quot;headerlink&quot; title=&quot;时间戳和日期的相互转化&quot;&gt;&lt;/a&gt;时间戳和日期的相互转化&lt;/h2&gt;&lt;p&gt;开发中,后台给我们的时间是以时间戳的格式,拿到这个时间戳后我们可能要转换成日期格式再进行其他操作,最后要给服务器上传数据的时候我们又要把日期转换成时间戳格式传给后台.&lt;/p&gt;
&lt;p&gt;时间戳转换日期&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// timestamp是后台返回给我们的时间戳&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;double dateStampInterval = timestamp/1000;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;expectedDate = [NSDate dateWithTimeIntervalSince1970:dateStampInterval];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;日期转换成时间戳&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;long long  expectedInterval = [currentDate timeIntervalSince1970]*1000;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;timeStamp = [NSString stringWithFormat:@&amp;quot;%lld&amp;quot;,expectedInterval];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;NSDateComponents的使用&quot;&gt;&lt;a href=&quot;#NSDateComponents的使用&quot; class=&quot;headerlink&quot; title=&quot;NSDateComponents的使用&quot;&gt;&lt;/a&gt;NSDateComponents的使用&lt;/h2&gt;&lt;p&gt;NSDateComponents类是一个面向对象的日期组件,封装了具体年月日、时秒分、周、季度等.我们既可以很方便的取得一个日期的具体组件,比如小时、分钟、秒、日、月、年等等,又可以指定一个日期组件.&lt;/p&gt;
&lt;p&gt;NSDateComponents类经常和NSCalendar类搭配使用，NSCalendar真正执行NSDate和NSDateComponents间的转换。这样，我们先要获取当前的calendar。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSCalendar *calendar = [NSCalendar currentCalendar];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSDateComponents *dateComponents = [calendar components:NSCalendarUnitDay|NSCalendarUnitMonth fromDate:currentDate];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;day=%zd, month=%zd&amp;quot;, dateComponents.day, dateComponents.month);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;day=1, month=2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;date components到date对象的转换&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSDateComponents *components = [[NSDateComponents alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;components.day = 7;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;components.month = 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;components.year = 2016;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSDate *newDate = [calendar dateFromComponents:components];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;%@&amp;quot;, newDate);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;2016-02-06 16:00:00 +0000&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GMT = Greenwich Mean Time（格林尼治标准时间）&lt;br&gt;CST = China Standard Time（中国标准时间）&lt;br&gt;CET = Central European Time(欧洲中部时间）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;components.timeZone = [NSTimeZone timeZoneWithAbbreviation:@&amp;quot;GMT&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;2016-02-07 00:00:00 +0000&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;比较日期和时间&quot;&gt;&lt;a href=&quot;#比较日期和时间&quot; class=&quot;headerlink&quot; title=&quot;比较日期和时间&quot;&gt;&lt;/a&gt;比较日期和时间&lt;/h2&gt;&lt;p&gt;先创建两个日期,date1和date2&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dateFormatter.dateFormat = @&amp;quot;MM dd, yyyy zzz&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dateString = @&amp;quot;02 1, 2016 GMT&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSDate *date1 = [dateFormatter dateFromString:dateString];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dateString = @&amp;quot;01 31, 2016 GMT&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSDate *date2 = [dateFormatter dateFromString:dateString];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;date1:%@, date2:%@&amp;quot;, date1, date2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// date1:2016-02-01 00:00:00 +0000, date2:2016-01-31 00:00:00 +0000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;earlierDate 和 laterDate&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 与anotherDate比较，返回较早的那个日期&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// - (NSDate *)earlierDate:(NSDate *)anotherDate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 与anotherDate比较，返回较晚的那个日期&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// - (NSDate *)laterDate:(NSDate *)anotherDate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;Earlier date is:%@&amp;quot;, [date1 earlierDate:date2]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Earlier date is:2016-01-31 00:00:00 +0000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;Later date is:%@&amp;quot;, [date1 laterDate:date2]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Later date is:2016-02-01 00:00:00 +0000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;另外一个日期比较方法是 NSDate 的 compare: 方法，它需要搭配使用 NSComparisonResult 枚举体。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if ([date1 compare:date2] == NSOrderedSame) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;Same dates&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; else if ([date1 compare:date2] == NSOrderedAscending) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;Date1 is Earlier than Date2&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; else if ([date1 compare:date2] == NSOrderedDescending) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;Date1 is Later than Date2&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;Date1 is Later than Date2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第三个比对方法有点不同，因为它用到了时间间隔（time interval)的概念。这个方法也很简单，它可以查找到每个日期（到现在）的时间间隔，接下来就可以进行比对。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if ([date1 timeIntervalSinceReferenceDate] &amp;gt; [date2 timeIntervalSinceReferenceDate]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;Date1 is Later than Date2&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; else if ([date1 timeIntervalSinceReferenceDate] &amp;lt; [date2 timeIntervalSinceReferenceDate]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;Date1 is Earlier than Date2&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; else if ([date1 timeIntervalSinceReferenceDate] == [date2 timeIntervalSinceReferenceDate]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      NSLog(@&amp;quot;Same dates&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Date1 is Later than Date2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;计算未来和过去的日期&quot;&gt;&lt;a href=&quot;#计算未来和过去的日期&quot; class=&quot;headerlink&quot; title=&quot;计算未来和过去的日期&quot;&gt;&lt;/a&gt;计算未来和过去的日期&lt;/h2&gt;&lt;p&gt;第一种做法用到的是 NSCAlendar 类的&lt;br&gt;dateByAddingUnit:value:toDate:options: 方法&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSInteger monthsToAdd = 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSInteger daysToAdd = 5;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;newDate = [calendar dateByAddingUnit:NSCalendarUnitMonth value:monthsToAdd toDate:currentDate options:NSCalendarWrapComponents];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;newDate = [calendar dateByAddingUnit:NSCalendarUnitDay value:daysToAdd toDate:newDate options:NSCalendarWrapComponents];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;%@&amp;quot;, newDate);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 2016-04-06 12:54:02 +0000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第二种是用NSDateComponents类.具体做法是初始化一个 NSDateComponents 对象,并设置月份和天的信息.然后我们调用 NSCalendar 的另一个方法 dateByAddingComponents:toDate:options:,并最终获得我们需要的日期对象.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;components.month = monthsToAdd;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;components.day = daysToAdd;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;newDate = [calendar dateByAddingComponents:components toDate:currentDate options:NSCalendarWrapComponents];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;%@&amp;quot;, newDate);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 2016-04-06 12:57:54 +0000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第三种用到 NSDate 的 dateByAddingTimeInterval: 方法&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSTimeInterval hoursToAddInSeconds = 90 * 60;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;newDate = [currentDate dateByAddingTimeInterval:hoursToAddInSeconds];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;%@&amp;quot;, newDate);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// currentDate: 2016-02-02 03:29:09 +0000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 2016-02-02 04:59:09 +0000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意:因为闰秒、闰年或日光节约时间的缘故，它经常会得到错误的结果.&lt;/p&gt;
&lt;h2 id=&quot;计算日期间隔&quot;&gt;&lt;a href=&quot;#计算日期间隔&quot; class=&quot;headerlink&quot; title=&quot;计算日期间隔&quot;&gt;&lt;/a&gt;计算日期间隔&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//定义两个日期&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dateFormatter.dateFormat = @&amp;quot;HH:mm:ss MM dd, yyyy zzz&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dateString = @&amp;quot;09:49:20 02 1, 2016 GMT&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSDate *date1 = [dateFormatter dateFromString:dateString];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dateString = @&amp;quot;12:22:49 01 31, 2016 GMT&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSDate *date2 = [dateFormatter dateFromString:dateString];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;date1:%@, date2:%@&amp;quot;, date1, date2);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第一种计算方法是利用calendar的&lt;br&gt;- (NSDateComponents &lt;em&gt;)components:&lt;br&gt;(NSCalendarUnit)unitFlags fromDate:(NSDate &lt;/em&gt;)startingDate&lt;br&gt;toDate:(NSDate *)resultDate options:(NSCalendarOptions)opts;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSDateComponents *diffDateComponents = [calendar components:NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitDay|NSCalendarUnitHour|NSCalendarUnitMinute|NSCalendarUnitSecond fromDate:date1 toDate:date2 options:NSCalendarWrapComponents];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;The difference between dates is:%zd year,%zd month,%zd day,%zd hour, %zd minute, %zd second&amp;quot;, diffDateComponents.year, diffDateComponents.month, diffDateComponents.day, diffDateComponents.hour, diffDateComponents.minute, diffDateComponents.second);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// The difference between dates is:0 year,0 month,0 day,-21 hour, -26 minute, -31 second&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第二种方法NSDateComponentsFormatter&lt;/p&gt;
&lt;p&gt;NSDateComponentsFormatter 类，它提供了多种用于自动计算日期间隔的方法,并可以返回格式化字符串结果.&lt;/p&gt;
&lt;p&gt;初始化一个NSDateComponentsFormatter&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSDateComponentsFormatter *dateComponentsFormatter = [[NSDateComponentsFormatter alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dateComponentsFormatter.unitsStyle = NSDateComponentsFormatterUnitsStyleFull;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;stringFromTimeInterval&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt; interval = [date2 timeIntervalSinceDate:date1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *diffDateString = [dateComponentsFormatter stringFromTimeInterval:interval];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, diffDateString);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// -21 hours, 26 minutes, 31 seconds&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;stringFromDate:(NSDate &lt;em&gt;)startDate toDate:(NSDate &lt;/em&gt;)endDate;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dateComponentsFormatter.allowedUnits = NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitHour|NSCalendarUnitMinute|NSCalendarUnitSecond;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString *autoFormattedDifference = [dateComponentsFormatter stringFromDate:date2 toDate:date1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;%@&amp;quot;, autoFormattedDifference);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 0 years&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面这种写法有问题, 会crush, 报错”Specifying positional units with gaps is ambiguous, and therefore unsupported”,正确写法如下:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSInteger unitFlags = NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitHour|NSCalendarUnitMinute|NSCalendarUnitSecond;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dateComponentsFormatter.allowedUnits = unitFlags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString *autoFormattedDifference = [dateComponentsFormatter stringFromDate:date1 toDate:date2];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;%@&amp;quot;, autoFormattedDifference);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// -21 hours, 26 minutes, 31 seconds&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然还有一种方法,上面也有提到过,利用 timeIntervalSinceDate:全部转换成秒数,再通过一些单位换算比较也可算出间隔日期.&lt;/p&gt;
&lt;p&gt;除了掌握这些基本知识,还应该注意到时间编程的效率问题,比如过多使用NSDateFormatter将影响程序的性能等等问题.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;时间编程是我们在开发中经常要遇到,比如说时间戳的转换,根据日期更新数据,是否清除一周缓存,时间间隔计算等等,而这些点又比较零散,不容易系统的掌握iOS时间编程.此文就是通过一些经常要用到的方法作为例子,从上到下,系统的对时间编程总结.&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://blog.chusaikeji.com/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="http://blog.chusaikeji.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>《Cocoa-Design-Patterns》</title>
    <link href="http://blog.chusaikeji.com/2015/11/29/%E3%80%8ACocoa-Design-Patterns%E3%80%8B/"/>
    <id>http://blog.chusaikeji.com/2015/11/29/《Cocoa-Design-Patterns》/</id>
    <published>2015-11-29T14:41:00.000Z</published>
    <updated>2018-04-30T15:28:16.000Z</updated>
    
    <content type="html">&lt;p&gt;1.模型 - 视图 - 控制器&lt;/p&gt;
&lt;p&gt;2.两阶段创建&lt;/p&gt;
&lt;p&gt;3.模板方法&lt;/p&gt;
&lt;p&gt;4.动态创建&lt;/p&gt;
&lt;p&gt;5.通知&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;###三个类一个方法模拟iOS通知实现&lt;/p&gt;
&lt;h4 id=&quot;三个类&quot;&gt;&lt;a href=&quot;#三个类&quot; class=&quot;headerlink&quot; title=&quot;三个类:&quot;&gt;&lt;/a&gt;三个类:&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  @brief  关于通知的信息类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface MyNotification : NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, strong, readwrite) NSString *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, assign, readwrite) id object;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, strong, readwrite) NSDictionary *infoDictionary;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (id)initWithName:(NSString *)name object:(id)anObject userInfo:(NSDictionary *)someUserInfo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  @brief  存储关于注册的观察者的信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface MYNotificationObserverRecord : NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, assign, readwrite) id object;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, assign, readwrite) id observer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, assign, readwrite) SEL selector;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  @brief 单例模式 逻辑处理类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface MYNotificationCenter : NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, strong) NSMutableDictionary *observersDictionary;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (id)defaultCenter;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)addObserver:(id)notificationObserver selector:(SEL)notificationSelector name:(NSString *)notificationName object:(id)objectOfInterest;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)removeObserver:(id)notificationObserver;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)postNotification:(MyNotification *)aNotification;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)postNotification:(NSString *)aName object:(id)objectOfInterest userInfo:(NSDictionary *)someUserInfo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一个方法:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (id)performSelector:(SEL)aSelector withObject:(id)object;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;###注意几点:&lt;/p&gt;
&lt;p&gt;1.记得remove!记得remove!记得remove!&lt;br&gt;2.在接收通知的方法里加一个判断&lt;br&gt;&lt;code&gt;if (self.isViewLoaded &amp;amp;&amp;amp; self.view.window) {}&lt;/code&gt;&lt;br&gt;3.注意线程问题&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;1.模型 - 视图 - 控制器&lt;/p&gt;
&lt;p&gt;2.两阶段创建&lt;/p&gt;
&lt;p&gt;3.模板方法&lt;/p&gt;
&lt;p&gt;4.动态创建&lt;/p&gt;
&lt;p&gt;5.通知&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://blog.chusaikeji.com/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="http://blog.chusaikeji.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Simple-Custom-TabBarController</title>
    <link href="http://blog.chusaikeji.com/2015/09/16/Simple-Custom-TabBarController/"/>
    <id>http://blog.chusaikeji.com/2015/09/16/Simple-Custom-TabBarController/</id>
    <published>2015-09-16T07:36:00.000Z</published>
    <updated>2018-04-30T15:13:23.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;TabBarController&lt;/strong&gt;是&amp;lt;蓦然&amp;gt;项目主要框架结构, 一般来说系统自带的TabBarController已足够使用, 但是要做成 &amp;lt;蓦然&amp;gt; 项目中的样式(如下图), 就需要我们自定义一个TabBarController.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-a449e64eba7437eb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Alt text&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;思路分析&quot;&gt;&lt;a href=&quot;#思路分析&quot; class=&quot;headerlink&quot; title=&quot;思路分析&quot;&gt;&lt;/a&gt;思路分析&lt;/h2&gt;&lt;h3 id=&quot;总体思路&quot;&gt;&lt;a href=&quot;#总体思路&quot; class=&quot;headerlink&quot; title=&quot;总体思路&quot;&gt;&lt;/a&gt;总体思路&lt;/h3&gt;&lt;p&gt;自定义一个控件, 我们一般有两种选择:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完全重写&lt;/li&gt;
&lt;li&gt;继承重写&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两种方式各有所长, 在这我们主要是通过&lt;strong&gt;继承重写&lt;/strong&gt;来自定义TabBarController. &lt;/p&gt;
&lt;h3 id=&quot;掌握系统控件结构&quot;&gt;&lt;a href=&quot;#掌握系统控件结构&quot; class=&quot;headerlink&quot; title=&quot;掌握系统控件结构&quot;&gt;&lt;/a&gt;掌握系统控件结构&lt;/h3&gt;&lt;p&gt;在自定义UITabBarController之前, 首先我们必须了解UITabBarController结构与其各个相关类的关系:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TabBarController&lt;/li&gt;
&lt;li&gt;TabBar&lt;/li&gt;
&lt;li&gt;TabButton&lt;/li&gt;
&lt;li&gt;ViewController&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，TabButton是一个双态的Button（选中和未选中）。TabBar是TabButton的容器，负责TabButton的排布和互斥，保证同时只有一个Button为选中态。TabBarController包含了TabBar，并管理这一个ViewController的栈，在TabBar上的按钮点击时对栈上的ViewController位置进行相应的调整，从而保持TabBar和ViewController栈之间的一致性。&lt;/p&gt;
&lt;h3 id=&quot;自定义TabBarController思路&quot;&gt;&lt;a href=&quot;#自定义TabBarController思路&quot; class=&quot;headerlink&quot; title=&quot;自定义TabBarController思路&quot;&gt;&lt;/a&gt;自定义TabBarController思路&lt;/h3&gt;&lt;p&gt;理解了UITabBarController的结构, 而我们又是选择用继承重写的方式来自定义, 思路其实就很明了了:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承UITabBarController&lt;/li&gt;
&lt;li&gt;隐藏原有的TabBar, 自己写一个TabBar和TabBarItem&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;结构展示&quot;&gt;&lt;a href=&quot;#结构展示&quot; class=&quot;headerlink&quot; title=&quot;结构展示&quot;&gt;&lt;/a&gt;结构展示&lt;/h2&gt;&lt;h3 id=&quot;确定结构&quot;&gt;&lt;a href=&quot;#确定结构&quot; class=&quot;headerlink&quot; title=&quot;确定结构&quot;&gt;&lt;/a&gt;确定结构&lt;/h3&gt;&lt;p&gt;通过上面对系统原生的UITabBarView结构分析可知, 我们需要创建三个类:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TabBarController&lt;/li&gt;
&lt;li&gt;TabBar&lt;/li&gt;
&lt;li&gt;Button&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;项目结构图示&quot;&gt;&lt;a href=&quot;#项目结构图示&quot; class=&quot;headerlink&quot; title=&quot;项目结构图示&quot;&gt;&lt;/a&gt;项目结构图示&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-aa999d6fc1f792e4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-b08016e7e3458c94.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;关键点分析&quot;&gt;&lt;a href=&quot;#关键点分析&quot; class=&quot;headerlink&quot; title=&quot;关键点分析&quot;&gt;&lt;/a&gt;关键点分析&lt;/h2&gt;&lt;h3 id=&quot;1-如何把自己创建的Button和viewController关联起来-页面切换&quot;&gt;&lt;a href=&quot;#1-如何把自己创建的Button和viewController关联起来-页面切换&quot; class=&quot;headerlink&quot; title=&quot;1. 如何把自己创建的Button和viewController关联起来(页面切换)?&quot;&gt;&lt;/a&gt;1. 如何把自己创建的Button和viewController关联起来(页面切换)?&lt;/h3&gt;&lt;p&gt;因为我们都是继承自系统, 所以还是直接用系统的selectedIndex属性来实现. 又因为TabBar和TabBarController是两个类, 我们的点击方法是在TabBar里, 而页面切换是在TabBarController里, 所以这里要用&lt;strong&gt;协议&lt;/strong&gt;来关联两者.&lt;/p&gt;
&lt;h3 id=&quot;2-自定义的几个Button如何只选中一个-以及选中状态的切换&quot;&gt;&lt;a href=&quot;#2-自定义的几个Button如何只选中一个-以及选中状态的切换&quot; class=&quot;headerlink&quot; title=&quot;2. 自定义的几个Button如何只选中一个, 以及选中状态的切换?&quot;&gt;&lt;/a&gt;2. 自定义的几个Button如何只选中一个, 以及选中状态的切换?&lt;/h3&gt;&lt;p&gt;利用KVO来监控Button的title、image、selectedImage属性.&lt;/p&gt;
&lt;h3 id=&quot;3-Button如何布局&quot;&gt;&lt;a href=&quot;#3-Button如何布局&quot; class=&quot;headerlink&quot; title=&quot;3. Button如何布局?&quot;&gt;&lt;/a&gt;3. Button如何布局?&lt;/h3&gt;&lt;p&gt;在layoutSubviews方法中写代码布局. 方法很简单其实, 在创建button的时候, 顺便用一个数组来记录button的个数. 然后在layoutSubviews方法中, 循环取出, 对应设置frame. 一定不要忘记调用super方法!&lt;/p&gt;
&lt;h3 id=&quot;4-中间的button是如何加上去的&quot;&gt;&lt;a href=&quot;#4-中间的button是如何加上去的&quot; class=&quot;headerlink&quot; title=&quot;4. 中间的button是如何加上去的?&quot;&gt;&lt;/a&gt;4. 中间的button是如何加上去的?&lt;/h3&gt;&lt;p&gt;中间的button跟其他几个需求是不一样的, 所以单独添加. 道理也是一样, 创建一个button, 添加到TabBar上, 然后在设置button布局的layoutSubviews方法中设置中间button的位置. 他的点击事件跟其他button不一样, 所以在上面提到的协议里再加一个方法.&lt;/p&gt;
&lt;h2 id=&quot;部分代码展示&quot;&gt;&lt;a href=&quot;#部分代码展示&quot; class=&quot;headerlink&quot; title=&quot;部分代码展示&quot;&gt;&lt;/a&gt;部分代码展示&lt;/h2&gt;&lt;p&gt;TabBar.h&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-150a5d5a2e0c115e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Alt text&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;%E7%82%B9%E5%87%BB%E5%8E%BB%E7%9C%8B%E6%BA%90%E7%A0%81&quot;&gt;点击去看源码&lt;/a&gt; (源码暂未上传…后续会补上)&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;总之, 最主要的是要理解系统原生的UITabBarController结构, 善用工具 (代码) 才能游刃有余的把他定制成我们想要的.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;一定要记住, 代码就是工具, 用工具去解决问题&lt;/p&gt;
&lt;hr&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;TabBarController&lt;/strong&gt;是&amp;lt;蓦然&amp;gt;项目主要框架结构, 一般来说系统自带的TabBarController已足够使用, 但是要做成 &amp;lt;蓦然&amp;gt; 项目中的样式(如下图), 就需要我们自定义一个TabBarController.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-a449e64eba7437eb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Alt text&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://blog.chusaikeji.com/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="http://blog.chusaikeji.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>项目目录结构</title>
    <link href="http://blog.chusaikeji.com/2015/09/16/%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <id>http://blog.chusaikeji.com/2015/09/16/项目目录结构/</id>
    <published>2015-09-16T07:33:00.000Z</published>
    <updated>2018-04-30T15:18:27.000Z</updated>
    
    <content type="html">&lt;p&gt;今天跟大家分享一下工程的项目结构,  闲话不多说, 直接上图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-a5832f1bf4c366c1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上图可以很直观的看出, 主目录是按照业务来划分的, 内目录是按照模块划分的. 下面逐个解释一下:&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h2&gt;&lt;h3 id=&quot;Controller、View、Model&quot;&gt;&lt;a href=&quot;#Controller、View、Model&quot; class=&quot;headerlink&quot; title=&quot;Controller、View、Model&quot;&gt;&lt;/a&gt;Controller、View、Model&lt;/h3&gt;&lt;p&gt;按照典型的MVC模式划分, Controller对应的是所有模块的controller文件, View对应的是继承自view有关的文件, Model对应的是逻辑层的处理.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;说到项目架构, 现在流行的有MVC、MVVM、VIPER等. 很多同学一开始就在纠结到底用哪种, 这一下就给自己难住了, 没有必要, 对于新手而言, 就采用MVC, 更容易理解. 包括MVVM、VIPER其实都是MVC的演化版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从上图可以看出, 我们的MVC是按照tab来划分的, 蓦然项目中有两个tab, 一个是广场, 一个是我的, 再加上登录注册, 所以划分成这三部分.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在划分model的时候有一个争议, 我们没有去建解析json的model层, 我们是直接解析后拿来用, 没有再去转为model对象. 这样做有利有弊, 希望能和大家探讨一下.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;其他文件夹&quot;&gt;&lt;a href=&quot;#其他文件夹&quot; class=&quot;headerlink&quot; title=&quot;其他文件夹&quot;&gt;&lt;/a&gt;其他文件夹&lt;/h3&gt;&lt;h4 id=&quot;Public&quot;&gt;&lt;a href=&quot;#Public&quot; class=&quot;headerlink&quot; title=&quot;Public&quot;&gt;&lt;/a&gt;Public&lt;/h4&gt;&lt;p&gt;这个目录放一些公用的类, 具体结构如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-35c8c73984e5fb13.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;Header&quot;&gt;&lt;a href=&quot;#Header&quot; class=&quot;headerlink&quot; title=&quot;Header&quot;&gt;&lt;/a&gt;Header&lt;/h5&gt;&lt;p&gt;放一些宏、或者公用的头文件等&lt;/p&gt;
&lt;h5 id=&quot;Resource&quot;&gt;&lt;a href=&quot;#Resource&quot; class=&quot;headerlink&quot; title=&quot;Resource&quot;&gt;&lt;/a&gt;Resource&lt;/h5&gt;&lt;p&gt;图片资源相关文件&lt;/p&gt;
&lt;h5 id=&quot;CacheData&quot;&gt;&lt;a href=&quot;#CacheData&quot; class=&quot;headerlink&quot; title=&quot;CacheData&quot;&gt;&lt;/a&gt;CacheData&lt;/h5&gt;&lt;p&gt;数据持久化相关文件&lt;/p&gt;
&lt;h5 id=&quot;Network&quot;&gt;&lt;a href=&quot;#Network&quot; class=&quot;headerlink&quot; title=&quot;Network&quot;&gt;&lt;/a&gt;Network&lt;/h5&gt;&lt;p&gt;网络层有关的文件&lt;/p&gt;
&lt;h4 id=&quot;Libary&quot;&gt;&lt;a href=&quot;#Libary&quot; class=&quot;headerlink&quot; title=&quot;Libary&quot;&gt;&lt;/a&gt;Libary&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-1728354e5b5b324a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个目录存放的是一些第三方框架文件, 从图上可以看出, 项目中用到了6个三方框架. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;除了手动管理三方框架, 我们还可以用Cocoapods来自动导入第三方框架, 很方便, 但也有缺陷. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;Frameworks&quot;&gt;&lt;a href=&quot;#Frameworks&quot; class=&quot;headerlink&quot; title=&quot;Frameworks&quot;&gt;&lt;/a&gt;Frameworks&lt;/h4&gt;&lt;p&gt;导入的一些框架文件&lt;/p&gt;
&lt;h4 id=&quot;APP&quot;&gt;&lt;a href=&quot;#APP&quot; class=&quot;headerlink&quot; title=&quot;APP&quot;&gt;&lt;/a&gt;APP&lt;/h4&gt;&lt;p&gt;AppDelegate.h 和 AppDelegate.m 文件&lt;/p&gt;
&lt;h2 id=&quot;拿到项目怎么办&quot;&gt;&lt;a href=&quot;#拿到项目怎么办&quot; class=&quot;headerlink&quot; title=&quot;拿到项目怎么办&quot;&gt;&lt;/a&gt;拿到项目怎么办&lt;/h2&gt;&lt;p&gt;拿到一个项目, 首要的是确定主体框架是什么, 在脑海里迅速形成根据主体框架来确定的目录结构, 然后以最快的速度把项目的框架搭建出来. 如果是团队协作的项目, 就可以根据目录结构去做各自负责的那一部分了.&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;有一个清晰明了的项目结构, 可以体现出我们的开发素质, 以及我们对整个项目的理解, 也是提高团队开发效率必不可少的. 相反的, 我们去一家公司, 怎么看刚接触的项目, 也是按照目录来看. 有一定经验后, 只看目录就可以对整个项目有一个整体的把握了.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天跟大家分享一下工程的项目结构,  闲话不多说, 直接上图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-a5832f1bf4c366c1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上图可以很直观的看出, 主目录是按照业务来划分的, 内目录是按照模块划分的. 下面逐个解释一下:&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://blog.chusaikeji.com/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="http://blog.chusaikeji.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 歌词解析</title>
    <link href="http://blog.chusaikeji.com/2015/07/03/iOS%E6%AD%8C%E8%AF%8D%E8%A7%A3%E6%9E%90/"/>
    <id>http://blog.chusaikeji.com/2015/07/03/iOS歌词解析/</id>
    <published>2015-07-03T09:35:00.000Z</published>
    <updated>2018-04-30T15:10:17.000Z</updated>
    
    <content type="html">&lt;p&gt;之前,写了一个关于莫文蔚的app,因为版权的问题被苹果拒了,然后也再没动,这几天又拿出来看了看,感觉歌词解析这部分挺有意思的,拿出来说一说.&lt;/p&gt;
&lt;p&gt;这个是做好的效果&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-d999b1e2b70ffa59.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;首先,我们来看看歌词都是怎么展示的,下几个音乐类软件看看,能滚动,被选中的歌词高亮,都是这两个特点,所以猜测是用tableview来显示歌词的.拿虾米验证了一下果然是.&lt;/p&gt;
&lt;p&gt;然后,我们要弄明白lrc歌词有哪些格式,上网查,或者抓包都可以看到.一般来说lrc歌词有三种格式:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-bd5f047be5f07757.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;格式一&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-d7da602bdf5c907a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;格式二&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-63a17f53dbfab6e5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;格式三&quot;&gt;&lt;/p&gt;
&lt;p&gt;其实还有一种格式, 是像KTV一样的效果, 每个字对应一个时间点, 在这咱们也用不到就不列举了.&lt;/p&gt;
&lt;p&gt; 明白了上面的两点,我们来看看整体的思路,其实就两点:&lt;br&gt;       1.歌词解析&lt;br&gt;       2.动态显示&lt;br&gt; 那么,咱们继续往下展开.先来看歌词解析&lt;/p&gt;
&lt;p&gt; 一般情况下,只需要解析一种格式就可以了,但是,问题是这些歌词都是抓的接口,我们所要做的就是把这三种格式都解析出来.这个地方其实涉及到一个思维的问题,如果你一开始就想着怎么把这三种格式都解析出来,恐怕是很困难的.所以我们找一个好上手的,先解析出来一个,然后再去关注另外两种.&lt;/p&gt;
&lt;p&gt; 附上部分代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSArray *array = [contentString componentsSeparatedByString:@&amp;quot;\n&amp;quot;];

for (int i = 0; i &amp;lt; [array count]; i++) {

    NSString *lineString = [array objectAtIndex:i];

    NSArray *lineArray = [lineString componentsSeparatedByString:@&amp;quot;]&amp;quot;];

    if ([lineArray[0] length] &amp;gt; 8) {

        NSString *str1 = [lineString substringWithRange:NSMakeRange(3, 1)];

        NSString *str2 = [lineString substringWithRange:NSMakeRange(6, 1)];

        if ([str1 isEqualToString:@&amp;quot;:&amp;quot;] &amp;amp;&amp;amp; [str2 isEqualToString:@&amp;quot;.&amp;quot;]) {

            for (int i = 0; i &amp;lt; lineArray.count - 1; i++) {

                NSString *lrcString = [lineArray objectAtIndex:lineArray.count - 1];

                //分割区间求歌词时间
                NSString *timeString = [self timeToSecond:[[lineArray objectAtIndex:i] substringWithRange:NSMakeRange(1, 5)]];

                self.lrcDictionary = [NSMutableDictionary dictionary];

                //把时间 和 歌词 加入词典
                [self.lrcDictionary setObject:lrcString forKey:timeString];
              }
          }
      }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这一步咱们就把歌词解析出来了,放到了一个字典当中.以上还有两个要注意的问题,一是要把&lt;em&gt;时间转换为秒&lt;/em&gt;,二是要给解析出来的歌词&lt;em&gt;按照时间排序&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;解析歌词的部分就完成了,剩下的任务就是动态显示了,怎么能够让歌词动态显示呢,主要用到下面两个方法:&lt;br&gt;       1.NSTimer&lt;br&gt;       2.被选中的行移动到中间&lt;br&gt;       &lt;code&gt;- (void)selectRowAtIndexPath:(NSIndexPath*)indexPath animated:(BOOL)animated scrollPosition:(UITableViewScrollPosition)scrollPosition;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在这里注意的是,定义一个NSUInteger,表示当前歌词行数,通过NSTimer每次把NSUInteger传到&lt;br&gt;&lt;code&gt;selectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated scrollPosition:(UITableViewScrollPosition)scrollPosition&lt;/code&gt;&lt;br&gt;这个方法.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 使被选中的行移到中间
NSIndexPath *indexPath = [NSIndexPath indexPathForRow:lineNumber inSection:0];
[self.lrcTableView selectRowAtIndexPath:indexPath animated:YES scrollPosition:UITableViewScrollPositionMiddle];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;至此,整个思路就完成了,中间肯定有很多的细节问题需要处理,由于暂时没想好怎么去说这些细节的东西,留待以后如果有思路再补充.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;之前,写了一个关于莫文蔚的app,因为版权的问题被苹果拒了,然后也再没动,这几天又拿出来看了看,感觉歌词解析这部分挺有意思的,拿出来说一说.&lt;/p&gt;
&lt;p&gt;这个是做好的效果&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-d999b1e2b70ffa59.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://blog.chusaikeji.com/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="http://blog.chusaikeji.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>KVO-NSNotification</title>
    <link href="http://blog.chusaikeji.com/2015/03/15/KVO-NSNotification/"/>
    <id>http://blog.chusaikeji.com/2015/03/15/KVO-NSNotification/</id>
    <published>2015-03-15T11:48:00.000Z</published>
    <updated>2018-04-30T15:38:39.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;NSNotification-通知中心&quot;&gt;&lt;a href=&quot;#NSNotification-通知中心&quot; class=&quot;headerlink&quot; title=&quot;NSNotification 通知中心&quot;&gt;&lt;/a&gt;NSNotification 通知中心&lt;/h2&gt;&lt;p&gt;苹果提供的一种消息机制, 观察者只要向消息中心注册， 即可接受其他对象发送来的消息，消息发送者和消息接受者两者可以互相一无所知，完全解耦。NSNotification可以应用于任意时间和任何对象，观察者可以有多个, 这也正是他跟delegate的区别.&lt;/p&gt;
&lt;h4 id=&quot;使用步骤&quot;&gt;&lt;a href=&quot;#使用步骤&quot; class=&quot;headerlink&quot; title=&quot;使用步骤:&quot;&gt;&lt;/a&gt;使用步骤:&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;注册一个观察者&lt;/li&gt;
&lt;li&gt;给通知中心发送一个消息&lt;/li&gt;
&lt;li&gt;清除观察者&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码:&quot;&gt;&lt;/a&gt;代码:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  *  注册一个观察者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  *  @param observer 谁去接受消息, 执行方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  *  @param selector 一旦接收到消息, 要执行的方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  *  @param name 要监听的事件, 以字符串区分&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  *  @param object 限定发出消息的对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)addObserver:(id)observer selector:(SEL)aSelector name:(NSString *)aName object:(id)anObject;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;```2.给通知中心发布消息&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


/**
 *  给通知中心发布消息
 *
 *  @param notification 传递一个通知
 */
- (void)postNotification:(NSNotification *)notification;


/**
 *  给通知中心发布消息
 *
 *  @param aName    事件名称
 *  @param anObject 给消息的接受者传递一个参数
 */
- (void)postNotificationName:(NSString *)aName object:(id)anObject;


/**
 *  给通知中心发布消息
 *
 *  @param aName     事件的名称
 *  @param anObject  给消息的接受者传递一个参数
 *  @param aUserInfo 多个参数以字典形式传递
 */
- (void)postNotificationName:(NSString *)aName object:(id)anObject userInfo:(NSDictionary *)aUserInfo;



&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     *  移除全部观察者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     *  @param observer &amp;lt;#observer description#&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    - (void)removeObserver:(id)observer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     *  移除指定观察者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     *  @param observer &amp;lt;#observer description#&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     *  @param aName    &amp;lt;#aName description#&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     *  @param anObject &amp;lt;#anObject description#&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    - (void)removeObserver:(id)observer name:(NSString *)aName object:(id)anObject;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 应用场景:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1. 控制器与一个或多个任意的对象进行通信(监控)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. UIDevice通知&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. 键盘通知&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## KVO&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Key-Value Observing，是Foundation框架提供的一种机制，使用KVO，可以方便地对指定对象的某个属性进行观察，当属性发生变化时，进行通知.        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 实现步骤&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1. 由被观察的对象调用方法, 添加观察者 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. 一旦被观察的属性发生改变, 系统会调用这个方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. 解除观察者身份 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ```1. 添加观察者&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

/**
 *  由被观察的对象调用方法, 添加观察者
 *
 *  @param observer 观察者
 *  @param keyPath  观察(监控)哪一个属性
 *  @param options  设定通知观察者时传递的属性值，是传改变前的呢，还是改变后的
 *  @param context  一些其他的需要传递给观察者的上下文信息，通常设置为nil
 */
- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context;


&lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;一旦被观察的属性发生变化, 系统就会调用这个方法&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  必须要实现的方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  @param keyPath 监控的属性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  @param object  是我们 监听的对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  @param change  里面包含了keyPath对应的新值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  @param context 一些其他的需要传递给观察者的上下文信息，通常设置为nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;```3. 移除观察者&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

/**
 *  解除观察者的身份
 *
 *  @param observer 观察者
 *  @param keyPath  监控的属性
 */
- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是, 在ARC和MRC下都要移除观察者, 在ARC下不调用[super dealloc]&lt;/p&gt;
&lt;h4 id=&quot;相关文章&quot;&gt;&lt;a href=&quot;#相关文章&quot; class=&quot;headerlink&quot; title=&quot;相关文章:&quot;&gt;&lt;/a&gt;相关文章:&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.kyleduo.com/?p=270&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.kyleduo.com/?p=270&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSNotification_Class/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSNotification_Class/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mobile.51cto.com/iphone-386316.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mobile.51cto.com/iphone-386316.htm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/users/65e7fdcab03c/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.jianshu.com/users/65e7fdcab03c/latest_articles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.hpique.com/2013/12/nsnotificationcenter-part-1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.hpique.com/2013/12/nsnotificationcenter-part-1/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;NSNotification-通知中心&quot;&gt;&lt;a href=&quot;#NSNotification-通知中心&quot; class=&quot;headerlink&quot; title=&quot;NSNotification 通知中心&quot;&gt;&lt;/a&gt;NSNotification 通知中心&lt;/h2&gt;&lt;p&gt;苹果提供的一种消息机制, 观察者只要向消息中心注册， 即可接受其他对象发送来的消息，消息发送者和消息接受者两者可以互相一无所知，完全解耦。NSNotification可以应用于任意时间和任何对象，观察者可以有多个, 这也正是他跟delegate的区别.&lt;/p&gt;
&lt;h4 id=&quot;使用步骤&quot;&gt;&lt;a href=&quot;#使用步骤&quot; class=&quot;headerlink&quot; title=&quot;使用步骤:&quot;&gt;&lt;/a&gt;使用步骤:&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;注册一个观察者&lt;/li&gt;
&lt;li&gt;给通知中心发送一个消息&lt;/li&gt;
&lt;li&gt;清除观察者&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://blog.chusaikeji.com/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="http://blog.chusaikeji.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>高屋建瓴，iOS 地图开发</title>
    <link href="http://blog.chusaikeji.com/2015/03/07/%E9%AB%98%E5%B1%8B%E5%BB%BA%E7%93%B4,-iOS%E5%9C%B0%E5%9B%BE%E5%BC%80%E5%8F%91/"/>
    <id>http://blog.chusaikeji.com/2015/03/07/高屋建瓴,-iOS地图开发/</id>
    <published>2015-03-07T08:49:00.000Z</published>
    <updated>2018-04-30T15:19:22.000Z</updated>
    
    <content type="html">&lt;p&gt;在 iOS 中, 地图开发经常会用到的三个框架, 一个是苹果系统自带的 MapKit 框架, 另外两个, 一个是百度地图 BMKMapView, 另一个是高德地图 MAMapView. 当时我莫名的对一个问题产生了浓厚的兴趣, 就是百度地图和高德地图英文命名是什么意思!? 于是我就毫不蛋疼的去 google 了, 而且还在他俩的社区提了这个问题! 终于, 在我的努力下弄明白他俩代表的意思了.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;先看百度地图 BMKMapView, 代表的就是Baidu Map Kit MapView&lt;br&gt;再看高德地图 MAMapView,   “A map”就是一张地图，这个品牌的诞生就是为了做好一张地图&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于地图开发, 我觉得还应该从高处把握, 然后一点一点往下剥, 思路会非常清晰. 其实, 不单单是地图开发, 对于其他知识的学习也应该从高处把握, 否则, 会感觉凌乱, 没有头绪. 下面我们就看看怎么从高处把握地图开发的框架. (以高德地图为例, 百度地图其实也是一样的, 只是换了个名字).&lt;/p&gt;
&lt;p&gt;我觉得这个”高”主要体现在两个方面, 一个是把握好下面这些类, 而这些类就是一个主线, 是形成在我们脑海里的主干线路, 要理清楚哪一条道是转弯道, 哪一条道是单行道, 哪一条是非机动车道, 每一个类的功能都了然于胸, 用的时候自然而然很快速的找到我们所需要的.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;BMKMapView&lt;/td&gt;
&lt;td&gt;地图显示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BMKLocationService&lt;/td&gt;
&lt;td&gt;定位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BMKPoisearch&lt;/td&gt;
&lt;td&gt;周边检索&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BMKAnnotationView&lt;/td&gt;
&lt;td&gt;标注&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BMKGeoCodeSearch&lt;/td&gt;
&lt;td&gt;地理编码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BMKOverlayView&lt;/td&gt;
&lt;td&gt;覆盖物图层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BMKOfflineMap&lt;/td&gt;
&lt;td&gt;离线地图&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;上面是百度地图的一些类, 高德地图其实是一样的, 就是名字变了而已.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;MAMapView&lt;/td&gt;
&lt;td&gt;地图显示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MAUserLocation&lt;/td&gt;
&lt;td&gt;定位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AMapSearchAPI&lt;/td&gt;
&lt;td&gt;周边检索&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MAAnnotationView&lt;/td&gt;
&lt;td&gt;标注&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AMapGeocode&lt;/td&gt;
&lt;td&gt;地理编码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MAOverlayView&lt;/td&gt;
&lt;td&gt;覆盖物图层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MAOfflineMap&lt;/td&gt;
&lt;td&gt;离线地图&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这个地方你就会明白为什么开头会讲到他俩英文命名的含义了吧. 后面要说到的方法也是这个道理, 咱们要找到共性, 区别差异. 所以, 更简单的就是7个英文单词.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;主干&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;MapView&lt;/td&gt;
&lt;td&gt;地图显示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Location&lt;/td&gt;
&lt;td&gt;定位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Search&lt;/td&gt;
&lt;td&gt;周边检索&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Annotation&lt;/td&gt;
&lt;td&gt;标注&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Geocode&lt;/td&gt;
&lt;td&gt;地理编码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Overlay&lt;/td&gt;
&lt;td&gt;覆盖物图层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Offline&lt;/td&gt;
&lt;td&gt;离线地图&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;所以, 你不用为一长串一长串的方法苦恼了, 这是一个单词匹对的游戏.&lt;/p&gt;
&lt;p&gt;好了, 目前为止咱们这个主干就建立起来了, 有什么需求就尽管提吧. 拿最基本的一个需求来说吧—地图显示. 根据咱们的主干知识, 快速定位, 很明了, 就是 MAMapView. 到这就要用到我之前博客里说到的方法&lt;a href=&quot;http://www.jianshu.com/p/2d4693cbdbd7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《iOS 学习技巧之”查”》&lt;/a&gt;, 点进去看, 所有接口都可以看到，并且都有注释，应该说是很好理解了.&lt;/p&gt;
&lt;p&gt;当然, 除此之外, 再配合百度地图和高德地图官方资料教程, 以及 google 的各种资料, 拿下地图这一块不是问题.&lt;/p&gt;
&lt;p&gt;最后分享一些资料给大家&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://lbs.amap.com/api/ios-sdk/summary/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;概述 高德地图 API&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://lbs.amap.com/Public/reference/iOS%20API%20v2_3D/interface_m_a_offline_map.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;高德地图 iOS SDK 3D 地图&amp;amp;搜索服务参考手册 V2.4.1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;高德地图视频教程&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://v.youku.com/v_show/id_XODI2NTQyMTMy.html?firsttime=0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何使用 iOS SDK 进行开发01——开发你的第一个地图应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://v.youku.com/v_show/id_XODI2NTQ4Njg0.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何使用 iOS SDK 进行开发02——附近搜索&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://v.youku.com/v_show/id_XODI2NTQ5NjQ4.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何使用 iOS SDK 进行开发03——自定义 AnnotationView&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://v.youku.com/v_show/id_XODI2NTUxNjU2.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何使用 iOS SDK 进行开发04——路线规划&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;高德地图开发者认证群: 253476702&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/milkmap/tag/%E5%9C%B0%E5%9B%BEAPI/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/milkmap/tag/%E5%9C%B0%E5%9B%BEAPI/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://developer.baidu.com/map/index.php?title=iossdk/guide/introduction&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;百度地图开发指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://wiki.lbsyun.baidu.com/cms/iossdk/doc/v2_6_0/BaiduMap_IOSSDK_v2.6.0_Docs/html/annotated.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;百度地图 SDK for iOS v2.6.0 类参考&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在 iOS 中, 地图开发经常会用到的三个框架, 一个是苹果系统自带的 MapKit 框架, 另外两个, 一个是百度地图 BMKMapView, 另一个是高德地图 MAMapView. 当时我莫名的对一个问题产生了浓厚的兴趣, 就是百度地图和高德地图英文命名是什么意思!? 于是我就毫不蛋疼的去 google 了, 而且还在他俩的社区提了这个问题! 终于, 在我的努力下弄明白他俩代表的意思了.&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://blog.chusaikeji.com/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="http://blog.chusaikeji.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>SQLite 封装</title>
    <link href="http://blog.chusaikeji.com/2015/02/28/SQLite%E5%B0%81%E8%A3%85/"/>
    <id>http://blog.chusaikeji.com/2015/02/28/SQLite封装/</id>
    <published>2015-02-28T07:04:00.000Z</published>
    <updated>2018-04-30T15:30:02.000Z</updated>
    
    <content type="html">&lt;p&gt;iOS中的数据存储方式主要有:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Plist (NSArray/NSDictionary)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Preference(偏好设置/NSUserDefaults)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSCoding (NSKeyedArchiver/NSkeyedUnarchiver)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SQLite3&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Core Data&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;共5种方式, 其中前三种可归纳为文件存储, 适用于简单少量数据存储, 不适用于大批量数据存储; 后两种为数据库存储, 可存储大量数据. 今天主要是对SQLite进行一个简单的封装.首先对SQLite进行简单的一个介绍:&lt;/p&gt;
&lt;p&gt;SQLite是目前主流的轻量型嵌入式关系数据库. 它占用资源非常的低, 在嵌入式设备中, 可能只需要几百K的内存就够了, 它的处理速度比Mysql、PostgreSQL还快. 常见的适用于PC端的关系型数据库有Oracle、MySQL、SQL Server、DB2、Sybase, 而在嵌入式\移动客户端中, 我们主要使用的是SQLite. 下面直接上代码:&lt;br&gt;&lt;br&gt;&lt;br&gt;DataBaseHandler.h&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;
#import &amp;lt;sqlite3.h&amp;gt;


@interface DataBaseHandler : NSObject

{
    sqlite3 *dbPoint;
}


// 单例的创建方法
+ (DataBaseHandler *)shareInstance;


/**
 *  打开数据库
 *
 *  @param dbname 数据库名称
 *
 *  @text 哪个方法
 */
- (void)openDb:(NSString *)dbname text:(NSString *)text;


/**
 *  执行无返回值的sql
 *
 *  @param sql sql语句
 *
 *  @text 哪个方法
 */
- (void)executeNonReturnValue:(NSString *)sql text:(NSString *)text;


/**
 *  执行有返回值的sql
 *
 *  @param sql sql语句
 *
 *  @return 查询结果
 */
- (NSArray *)executeHaveReturnValue:(NSString *)sql;


/**
 *  判断数据库方法执行结果
 *
 *  @param result 调用数据库方法返回的结果
 *
 *  @text 哪个方法
 */
- (void)judgeResult:(int)result text:(NSString *)text;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   &lt;br&gt;&lt;/p&gt;
&lt;p&gt;DataBaseHandler.m&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;quot;DataBaseHandler.h&amp;quot;

@implementation DataBaseHandler


+ (DataBaseHandler *)shareInstance
{
    // 当第一次执行的时候会产生一个空指针
    static DataBaseHandler *dbHandler = nil;

    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
        // 对指针进行判断, 当第一次执行的时候创建一个对象
        if (dbHandler == nil) {
            dbHandler = [[DataBaseHandler alloc] init];
        }
    });

    // 无论是创建的和已经存在的, 都在这里直接return除去
    return dbHandler;
}


- (void)openDb:(NSString *)dbname text:(NSString *)text
{
    NSString *docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];
    NSString *dbPath = [docPath stringByAppendingString:dbname];

    // 参数1: 数据库文件存储的路径
    // 参数2: 数据库dbPoint指针地址
    // 返回值: 执行sqlite函数的结果(int类型)
    int result = sqlite3_open([dbPath UTF8String], &amp;amp;dbPoint);

    // 利用封装的方法判断结果
    [self judgeResult:result text:text];
}



- (void)executeNonReturnValue:(NSString *)sql text:(NSString *)text
{
    int result = sqlite3_exec(dbPoint, [sql UTF8String], NULL, NULL, NULL);
    [self judgeResult:result text:text];
}



- (NSArray *)executeHaveReturnValue:(NSString *)sql
{
    // 创建一个可变数组, 用于存储数据
    NSMutableArray *rows=[NSMutableArray array];

    // 创建一个数据库的替身, 存储对数据库的所有操作
    sqlite3_stmt *stmt = nil;

    /**
     *  让数据库执行sql语句, 并把结果保存到stmt中
     *
     *  @param dbPoint     数据库指针
     *  @param UTF8String] sql语句
     *  @param -1          限制sql语句的长度(如果是-1, 就是不限制)
     *  @param stmt        替身指针的地址
     *  @param NULL        空
     *
     */
    int result = sqlite3_prepare_v2(dbPoint, [sql UTF8String], -1, &amp;amp;stmt, NULL);

    // 判断是否正确
    if (SQLITE_OK == result) {

        // 当sql执行成功, 遍历数据
        // 循环遍历所有的结果, 每次遍历到一条数据, 都会返回sqlite_row, 如果没有数据了, 就不会返回SQLITE_ROW, 跳出循环
        while (SQLITE_ROW == sqlite3_step(stmt)) {

            // 取int类型的数据
            int columnCount = sqlite3_column_count(stmt);

            // 创建一个可变字典, 用来存储数据
            NSMutableDictionary *dic=[NSMutableDictionary dictionary];

            for (int i = 0; i &amp;lt; columnCount; i++) {

                // 在循环体中去按列取数据
                // 取得列名
                const char *name = sqlite3_column_name(stmt, i);

                // 取得某列的值
                const unsigned char *value = sqlite3_column_text(stmt, i);

                // 将char *字符串转为NSString字符串
                dic [[NSString stringWithUTF8String:name]] = [NSString stringWithUTF8String:(const char *) value];
            }

            [rows addObject:dic];
        }
    }

    // 销毁stmt替身, 把里面的操作和结果写入本地sqlite文件
    sqlite3_finalize(stmt);

    return rows;

}



- (void)judgeResult:(int)result text:(NSString *)text
{
    if (result == SQLITE_OK) {
        NSLog(@&amp;quot;%@成功&amp;quot;, text);
    } else {
        NSLog(@&amp;quot;错误代码: %d&amp;quot;, result);
        NSLog(@&amp;quot;%@失败&amp;quot;,text);
    }
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;以上就是我们对SQLite的一个简单封装. 在实际开发当中, 我们还会经常用到iOS平台的SQLite数据库框架FMDB, FMDB以OC的方式封装了SQLite的C语言API, 大家可以googol一下, 或者参考一下&lt;a href=&quot;https://github.com/ccgus/fmdb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git地址&lt;/a&gt;, 或者参考此文章&lt;a href=&quot;http://article.yeeyan.org/compare/307572&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FMDB的用法&lt;/a&gt;.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;iOS中的数据存储方式主要有:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Plist (NSArray/NSDictionary)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Preference(偏好设置/NSUserDefaults)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSCoding (NSKeyedArchiver/NSkeyedUnarchiver)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SQLite3&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Core Data&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://blog.chusaikeji.com/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="http://blog.chusaikeji.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>UITableView 景深效果</title>
    <link href="http://blog.chusaikeji.com/2015/02/13/UITableView%E6%99%AF%E6%B7%B1%E6%95%88%E6%9E%9C/"/>
    <id>http://blog.chusaikeji.com/2015/02/13/UITableView景深效果/</id>
    <published>2015-02-12T16:58:00.000Z</published>
    <updated>2018-04-30T15:16:17.000Z</updated>
    
    <content type="html">&lt;p&gt;景深效果在很多的app中都可以看到, 比较fashion. 他跟咱们在前几篇文章中提到的对UIScrollView和UITableView的理解息息相关. 下面具体来看看他是怎么实现的.&lt;/p&gt;
&lt;p&gt;要实现景深效果, 主要是理解两个方面:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;搞明白视图层级关系&lt;/li&gt;
&lt;li&gt;偏移量的改变而对应图片frame的改变&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先, 来看一下视图的层级关系&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-42a1f1c50b012cda.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;从上图中, 我们可以很清楚的看到整个景深效果的层级关系. 我们发现他的imageView整个是, 先放在view上的, 并且头部是超出屏幕一定距离的. 然后再放tableView, 那tableView不是把imageView给挡住了吗? 按照正常的话, 没错, 肯定是会给imageView挡上的, 此时就需要我们做一个小的调整, 给tableView设置headview, 并且让headview是透明的. 明白了吧, 我们一开始看见的imageView, 就是headview这一块内容.&lt;/p&gt;
&lt;p&gt;到这, 我们的景深效果就完成了一半, 剩下的一半就到了根据tableView的偏移量, 来调整imageView的位置, 看代码.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func scrollViewDidScroll(scrollView: UIScrollView) {

    var content = scrollView.contentOffset.y     
    var newRect = self.imageView!.frame

    // 判断当前偏移状态
    if content &amp;lt; 0 {            
        newRect.origin.y = -120 - content / 3            
    } else if content &amp;gt; 0 &amp;amp;&amp;amp; content &amp;lt; 200 {            
        newRect.origin.y = -120 - content
    }
    self.imageView!.frame = newRect 
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样, 我们整个的原理就讲完了, 最后, 附上完整的代码.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import UIKit

class MainViewController: UIViewController, UITableViewDataSource, UITableViewDelegate,     UIScrollViewDelegate {

// 定义为属性
var imageView : UIImageView?

// override关键字代表重写
override func viewDidLoad() {
    super.viewDidLoad()

    // Do any additional setup after loading the view.

    // 创建一个imageView
    self.imageView = UIImageView(frame: CGRect(x: self.view.frame.origin.x, y:-90, width: self.view.frame.size.width, height: 600))

    self.imageView!.image = UIImage(named:&amp;quot;beautiful.png&amp;quot;)
    self.view.addSubview(self.imageView!)

    // 创建tableView
    var tableView = UITableView(frame: CGRect(x: 0, y: 90, width: UIScreen.mainScreen().bounds.size.width, height: self.view.frame.size.height - 90), style: .Plain)
    tableView.backgroundColor = UIColor.clearColor()
    tableView.showsVerticalScrollIndicator = false;
    tableView.delegate = self
    tableView.dataSource = self
    self.view.addSubview(tableView)

    // 创建一块透明的区域来显示图片, 并且作为tableView的headview
    var view = UIView(frame: CGRect(x: 0, y: 0, width: self.view.frame.size.width, height: 200))
    view.backgroundColor = UIColor.clearColor()
    view.opaque = false;
    tableView.tableHeaderView = view        
}

func scrollViewDidScroll(scrollView: UIScrollView) {

    var content = scrollView.contentOffset.y

    var newRect = self.imageView!.frame

    // 判断当前偏移状态
    if content &amp;lt; 0 {

        newRect.origin.y = -120 - content / 3

    } else if content &amp;gt; 0 &amp;amp;&amp;amp; content &amp;lt; 200{

        newRect.origin.y = -120 - content            
    }        
    self.imageView!.frame = newRect        
}    

// 创建表示图
func numberOfSectionsInTableView(tableView: UITableView) -&amp;gt; Int {        
    return 3        
}    

func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int {        
    return 20        
}


func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&amp;gt; UITableViewCell {

    var cell : UITableViewCell?

    // as强转类型
    cell = tableView.dequeueReusableCellWithIdentifier(&amp;quot;cell&amp;quot;) as? UITableViewCell

    if cell == nil {            
        cell = UITableViewCell(style: .Subtitle, reuseIdentifier: &amp;quot;cell&amp;quot;)            
    }        
    cell!.detailTextLabel!.text = &amp;quot;\(indexPath.row)&amp;quot;

    return cell!        
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;分享使人快乐, 分享使人进步. 转载请注明出处&lt;a href=&quot;http://www.jianshu.com/p/3aea30ad0ff4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;柴茝&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;景深效果在很多的app中都可以看到, 比较fashion. 他跟咱们在前几篇文章中提到的对UIScrollView和UITableView的理解息息相关. 下面具体来看看他是怎么实现的.&lt;/p&gt;
&lt;p&gt;要实现景深效果, 主要是理解两个方面:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;搞明白视图层级关系&lt;/li&gt;
&lt;li&gt;偏移量的改变而对应图片frame的改变&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先, 来看一下视图的层级关系&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/193863-42a1f1c50b012cda.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://blog.chusaikeji.com/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="http://blog.chusaikeji.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Simple-Custom-ScrollView</title>
    <link href="http://blog.chusaikeji.com/2015/02/11/Simple-Custom-ScrollView/"/>
    <id>http://blog.chusaikeji.com/2015/02/11/Simple-Custom-ScrollView/</id>
    <published>2015-02-11T03:00:00.000Z</published>
    <updated>2018-04-30T15:12:26.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/7631a5b1dec5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇文章&lt;/a&gt;对UIScrollView的原理、属性和方法做了比较详细的理解, 本文旨在通过&lt;em&gt;自定义&lt;/em&gt;, 来实现一个简单的scrollView, 再次加深对其理解. &lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;在SimpleCustomScrollView.h&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;lt;UIKit/UIKit.h&amp;gt;

@interface SimpleCustomScrollView : UIView

// 咱们也定义一个跟系统一样的contentSize, 实现滚动的范围
@property (nonatomic) CGSize contentSize;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在SimpleCustomScrollView.m&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;quot;SimpleCustomScrollView.h&amp;quot;

@implementation SimpleCustomScrollView


- (instancetype)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame:frame];
    if (self) {

        // 给视图添加pan手势
        UIPanGestureRecognizer *gestureRecognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(handlePanGesture:)];
        [self addGestureRecognizer:gestureRecognizer];
    }
    return self;
}



- (void)handlePanGesture:(UIPanGestureRecognizer *)gestureRecognizer
{
    // translationInView 这个方法返回的是:在指定父视图坐标系统中, 横、纵坐标移动的坐标
    CGPoint translation = [gestureRecognizer translationInView:self];
    CGRect bounds = self.bounds;

    // 动态改变bounds
    CGFloat newBoundsOriginX = bounds.origin.x - translation.x;
    CGFloat minBoundsOriginX = 0.0;
    CGFloat maxBoundsOriginX = self.contentSize.width - bounds.size.width;
    bounds.origin.x = fmax(minBoundsOriginX, fmin(newBoundsOriginX, maxBoundsOriginX));

    CGFloat newBoundsOriginY = bounds.origin.y - translation.y;
    CGFloat minBoundsOriginY = 0.0;
    CGFloat maxBoundsOriginY = self.contentSize.height - bounds.size.height;
    bounds.origin.y = fmax(minBoundsOriginY, fmin(newBoundsOriginY, maxBoundsOriginY));

    self.bounds = bounds;

    // 因为拖动起来一直是在递增, 所以每次都要用 setTranslation: 方法置0
    [gestureRecognizer setTranslation:CGPointZero inView:self];

    // 真相只有一个, 打印一下
    NSLog(@&amp;quot;self.view&amp;apos;s bounds is : %@&amp;quot;, NSStringFromCGRect(self.bounds));
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ok. 到这, 咱们自定义的一个简单scrollView就完成了, 在viewController中测试一下&lt;/p&gt;
&lt;p&gt;在ViewController.m中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;quot;ViewController.h&amp;quot;
#import &amp;quot;SimpleCustomScrollView.h&amp;quot;

@interface ViewController ()

@property (nonatomic, strong) SimpleCustomScrollView *customScroll;

@end

@implementation ViewController


- (void)viewDidLoad
{
    [super viewDidLoad];

    self.view.backgroundColor = [UIColor whiteColor];

    self.customScroll = [[SimpleCustomScrollView alloc] initWithFrame:self.view.bounds];
    [self.view addSubview:self.customScroll];

    // 跟系统的一样, 在这我们也必须要设置contentSize的大小, 否则无法滚动
    self.customScroll.contentSize = CGSizeMake(0, 800);

    [self p_setupSubviews];

}


// 创建视图
- (void)p_setupSubviews
{
    // 因为老喝橙汁么, 所以就报答一下橙色了
    UIView *orangeView = [[UIView alloc] initWithFrame:CGRectMake(100, 200, 200, 200)];
orangeView.backgroundColor = [UIColor orangeColor];

[self.customScroll addSubview:orangeView];
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行一下, 是不是跟系统的一样可以滚动. ☀️ 最后附上&lt;a href=&quot;https://github.com/BraveMatchstickMen/SimpleCustomScrollView&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git地址&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/7631a5b1dec5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇文章&lt;/a&gt;对UIScrollView的原理、属性和方法做了比较详细的理解, 本文旨在通过&lt;em&gt;自定义&lt;/em&gt;, 来实现一个简单的scrollView, 再次加深对其理解. &lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://blog.chusaikeji.com/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="http://blog.chusaikeji.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>UITableView-Tips</title>
    <link href="http://blog.chusaikeji.com/2015/02/09/UITableView-Tips/"/>
    <id>http://blog.chusaikeji.com/2015/02/09/UITableView-Tips/</id>
    <published>2015-02-08T16:11:00.000Z</published>
    <updated>2018-04-30T15:15:17.000Z</updated>
    
    <content type="html">&lt;p&gt;UITabelView是iOS开发中最常用, 也是最灵活的控件, 所以, 如何打造出更符合用户体验的tableView, 是我们不断去思考的一个问题. 本文不去详细讲述tableView的基本属性和方法, 而是从tableView各种不同的用法和效果, 侧面阐述tableView.&lt;/p&gt;

&lt;hr&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;####1. 解决UITableView分割线距左边有距离的问题&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;我们在使用tableview时会发现分割线的左边会短一些，通常可以使用setSeparatorInset:UIEdgeInsetsZero 来解决。但是升级到XCode6之后，在iOS8里发现没有效果。下面给出解决办法：&lt;/p&gt;
&lt;p&gt;首先在viewDidLoad方法中加上如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if ([self.tableView respondsToSelector:@selector(setSeparatorInset:)]) {

[self.tableView setSeparatorInset:UIEdgeInsetsZero];

}

if ([self.tableView     respondsToSelector:@selector(setLayoutMargins:)]) {

[self.tableView setLayoutMargins:UIEdgeInsetsZero];

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在willDisplayCell方法中加入如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath

{

if ([cell respondsToSelector:@selector(setSeparatorInset:)]) {

[cell setSeparatorInset:UIEdgeInsetsZero];

}

if ([cell respondsToSelector:@selector(setLayoutMargins:)]) {

[cell setLayoutMargins:UIEdgeInsetsZero];

}

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此方法来自&lt;a href=&quot;http://www.wl566.com/wz/156547.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;####2. 点击cell上的Button获取cell的位置 (三种方法: tag, superView, block, 根据需求各自使用)&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;方法一: 利用superView获取&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 自定义cell: TestCell
TestCell *cell = [(TestCell *)[button superview] superview];
NSIndexPath *indexPath = [self.tableView indexPathForCell:cell];
NSLog(@&amp;quot;indexPath is = %li&amp;quot;,(long)indexPath.row);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;方法二: 通过Block来获取&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在自定义cell的.h文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;lt;UIKit/UIKit.h&amp;gt;

typedef void(^BlockButton)(UIButton *button);


@interface TestCell : UITableViewCell


@property (nonatomic, strong) UIButton *button;

@property (nonatomic, copy) BlockButton buttonBlock;

- (void)handlerButtonAction:(BlockButton)block;


@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   在自定义cell的.m文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;quot;TestCell.h&amp;quot;

@implementation TestCell


- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier
{
    self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];
    if (self) {
    [self p_setupSubviews];
    }
    return self;
}



- (void)p_setupSubviews
{
    self.button = [UIButton buttonWithType:UIButtonTypeSystem];
    self.button.frame = CGRectMake(self.frame.size.width-150, 10, 100, self.frame.size.height - 20);
    self.button.backgroundColor = [UIColor cyanColor];
    [self.button addTarget:self action:@selector(buttonAction:) forControlEvents:UIControlEventTouchUpInside];
    [self.contentView addSubview:self.button];
}



- (void)buttonAction:(UIButton *)button
{
    if (self.buttonBlock) {
        self.buttonBlock(button);
    }
}



- (void)handlerButtonAction:(BlockButton)block
{
    self.buttonBlock = block;
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在ViewController.m中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static NSString *str = @&amp;quot;test&amp;quot;;
    TestCell *cell = [tableView dequeueReusableCellWithIdentifier:str];
    if (!cell) {
        cell = [[TestCell alloc] initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:str];
    }

    [cell.button setTitle:[NSString stringWithFormat:@&amp;quot;%ld&amp;quot;, (long)indexPath.row] forState:UIControlStateNormal];

    [cell handlerButtonAction:^(UIButton *button) {
        NSLog(@&amp;quot;=======   %ld&amp;quot;, (long)indexPath.row);
        [cell.button setTitle:@&amp;quot;OK!&amp;quot; forState:UIControlStateNormal];

    }];
    return cell;
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;####3. 改变点击cell时cell的颜色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 利用selectedBackgroundView方法
UIView *aView = [[UIView alloc] initWithFrame:cell.contentView.frame];
aView.backgroundColor = [UIColor colorWithRed:155/255.0 green:34/255.0 blue:63/255.0 alpha:1.0];
cell.selectedBackgroundView = aView;
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;####4. cell的自适应&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// cell的高度问题, 都在这个方法中写
- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath
{

    // 1. 取数据

    NSString *name = [self.arr objectAtIndex:indexPath.row];

    // 2. 通过字符串的内容, 计算在一定宽度下, 文本占用的高度;

    NSDictionary *dic = @{NSFontAttributeName: [UIFont systemFontOfSize:17]};

    // 参数1: 通过CGSize给定一个宽度, 用来计算
    // 参数2: 通过以一个行为矩形, 计算高度
    // 参数3: 字体大小
    CGRect rect = [name boundingRectWithSize:CGSizeMake(tableView.frame.size.width, 10000) options:NSStringDrawingUsesLineFragmentOrigin attributes:dic context:nil];

    return rect.size.height;
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;####5. 去除多余的cell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 去除tableView多余的cell
self.tableView.tableFooterView = [[UIView alloc] init];
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;####6. 调整cell的间距&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在tableView样式为group时&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 创建一个UITableViewCell的子类，重写setfrme方法

-(void)setFrame:(CGRect)frame
 {
     frame.origin.y -= 5;
     frame.size.height -= 10;
     [super setFrame:frame];
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;注意&lt;/em&gt;: 上面的方法有待验证!&lt;/p&gt;
&lt;p&gt;第二种方法是, 把cell的backgroundColor设置为灰色, 在cell上加一个白色的view, 让view的height比cell的height少一点(cell需要空出来的距离)就可以了. 但是自己感觉这个方法有点low啊, 大家要是有什么好方法, 还望不吝赐教哦.&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;####7. UITableView的section&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当tableview样式为plain时, section需要自己设定大小, 而且section默认是不会随着tableview滚动的.&lt;/li&gt;
&lt;li&gt;当tableview样式为group时, section是自带的, section是跟随tableview滚动的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;####8. section 高度的问题&lt;/p&gt;
&lt;p&gt;tableview 样式为 group 时, section 会有一个默认的高度. 如果你不想要这个高度, 在代理方法中 return 0, 你会发现并没有什么效果. 这是因为 iOS 系统会把 0 默认为无效设置, 所以你只要 return 一个接近于 0 的数就可以了, 这里我们 return CGFLOAT_MIN.&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt;)tableView:(&lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; *)tableView heightForHeaderInSection:(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;)section&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CGFLOAT_MIN&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt;)tableView:(&lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; *)tableView heightForFooterInSection:(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;)section&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CGFLOAT_MIN&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当你设置了上面的方法后, 充满期待的打开模拟器, 发现在 tableview 顶部还有一个大约 20 的 padding. 这是因为 iOS 7 的 View 默认是渗透到状态栏上面的, 所以需要再加一句&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.automaticallyAdjustsScrollViewInsets = &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;本文会持续更新…欢迎一起探讨完善此文章, 谢谢!&lt;/p&gt;
&lt;p&gt;分享使人快乐, 分享使人进步, 转载请注明出处&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/a156806f6b58&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.jianshu.com/p/a156806f6b58&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;UITabelView是iOS开发中最常用, 也是最灵活的控件, 所以, 如何打造出更符合用户体验的tableView, 是我们不断去思考的一个问题. 本文不去详细讲述tableView的基本属性和方法, 而是从tableView各种不同的用法和效果, 侧面阐述tableView.&lt;/p&gt;

&lt;hr&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://blog.chusaikeji.com/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="http://blog.chusaikeji.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>“不求甚解”之 UIView</title>
    <link href="http://blog.chusaikeji.com/2015/02/05/%E2%80%9C%E4%B8%8D%E6%B1%82%E7%94%9A%E8%A7%A3%E2%80%9D%E4%B9%8BUIView/"/>
    <id>http://blog.chusaikeji.com/2015/02/05/“不求甚解”之UIView/</id>
    <published>2015-02-05T03:50:00.000Z</published>
    <updated>2018-04-30T15:32:58.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;em&gt;inheritance&lt;/em&gt;&lt;br&gt;&lt;img src=&quot;http://pic002.cnblogs.com/images/2012/12069/2012080209370777.jpg&quot; alt=&quot;来自于网络&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;##常用属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;区分 frame, bounds, center&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;frame&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;The frame rectangle, which describes the view’s location and size in its superview’s coordinate system.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;一句话总结: 子视图相对于其父视图坐标原点的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;bounds &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;The bounds rectangle, which describes the view’s location and size in its own coordinate system.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;一句话总结: 视图在其自身坐标系中的位置和大小&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;center &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;The center of the frame.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;一句话总结: 子视图相对于父视图的中心点位置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;改变bounds, 改变的就是视图自身坐标系的原点数值&lt;/strong&gt;, 所以我们可以通过改变视图的bounds, 来达到调整视图子视图位置的目的, UIScrollView&lt;a href=&quot;http://www.jianshu.com/p/7631a5b1dec5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;滚动原理&lt;/a&gt;正是此原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对 &lt;em&gt;frame.size = bounds.size&lt;/em&gt; 的纠正, 看下图&lt;br&gt;&lt;img src=&quot;http://i.stack.imgur.com/3jcne.jpg&quot; alt=&quot;来自于stackOverflow&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上图中, 可以清楚的看出, 当视图发生旋转的时候, frame.size != bounds.size&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;@property (nonatomic) CGAffineTransform transform;&lt;ul&gt;
&lt;li&gt;控件矩阵变化, 包括平移、缩放、旋转, 默认为CGAffineTransformldentity&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/lc_obj/article/details/17454825&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/lc_obj/article/details/17454825&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;其他常用属性、方法&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如何调整自己的大小, 当superviews的bounds发生改变时 默认为UIViewAutoresizingNone&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// UIViewAutoresizingNone                 = 0,          视图将不进行自动尺寸调整&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;UIViewAutoresizingFlexibleLeftMargin&lt;/span&gt;   = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,     视图的左边界将随着父视图宽度的变化而按比例进行调整. 否则, 视图和其父视图的左边界的相对位置将保持不变.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;UIViewAutoresizingFlexibleWidth&lt;/span&gt;        = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,     视图的宽度将和父视图的宽度成比例变化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;UIViewAutoresizingFlexibleRightMargin&lt;/span&gt;  = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,     视图的右边界将随着父视图宽度的变化而按比例变化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;UIViewAutoresizingFlexibleTopMargin&lt;/span&gt;    = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,     视图的上边界将随着父视图的高度而成比例变化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;UIViewAutoresizingFlexibleHeight&lt;/span&gt;       = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,     视图的高度将和父视图的高度一起成比例变化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;UIViewAutoresizingFlexibleBottomMargin&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;      视图的底边界将随着父视图高度的变化而按比例进行变化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;UIViewAutoresizing&lt;/span&gt; autoresizingMask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 当前控件的父控件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt; *superview;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 当前控件的所有一级子控件, 注意其子控件的子控件并不包含在内&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; subviews;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 是否隐藏, 默认为NO&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;getter&lt;/span&gt; = isHidden) &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; hidden;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// BOOL类型, 是否让一个视图裁剪其子视图&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; clipsToBounds;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 内容模式, 主要用于指定控件内容(注意不是子控件)如何填充, 一般UIImageView经常使用, 默认为UIViewContentModeScaleToFill&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;UIViewContentMode&lt;/span&gt; contentMode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 控件的标示, 可以存储一些和当前控件有关的信息(但是注意只能是整形), 默认为0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt; tag;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;(ps. 还是用表格的形式吧, 代码的形式看着不是特别舒服…)&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要的一些方法&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;- (void)addSubview:(UIView *)view;&lt;/td&gt;
&lt;td&gt;添加子控件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- (void)removeFromSuperview;&lt;/td&gt;
&lt;td&gt;从父控件中移除当前控件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- (void)insertSubview:(UIView *)view atIndex:(NSInteger)index;&lt;/td&gt;
&lt;td&gt;在指定位置插入子控件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- (void)bringSubviewToFront:(UIView *)view;&lt;/td&gt;
&lt;td&gt;把指定的子视图移动到最前面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- (void)sendSubviewToBack:(UIView *)view;&lt;/td&gt;
&lt;td&gt;把指定的子视图移动到最后面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- (void)exchangeSubviewAtIndex:(NSInteger)index1 withSubviewAtIndex:(NSInteger)index2;&lt;/td&gt;
&lt;td&gt;交换两个指定索引位置的子视图&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;+ (void)beginAnimations:(NSString &lt;em&gt;)animationID context:(void &lt;/em&gt;)context;&lt;/td&gt;
&lt;td&gt;开始一段动画&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;+ (void)commitAnimations;&lt;/td&gt;
&lt;td&gt;结束一段动画，注意在开始和结束之间如果控件的某些属性发生变化iOS将以动画方式进行改变&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations NS_AVAILABLE_IOS(4_0);&lt;/td&gt;
&lt;td&gt;以block的形式执行一段动画，注意这个方法有几种相关的重载&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- (void)addGestureRecognizer:(UIGestureRecognizer *)gestureRecognizer NS_AVAILABLE_IOS(3_2);&lt;/td&gt;
&lt;td&gt;添加手势操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- (void)removeGestureRecognizer:(UIGestureRecognizer *)gestureRecognizer NS_AVAILABLE_IOS(3_2);&lt;/td&gt;
&lt;td&gt;移除手势操作&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;inheritance&lt;/em&gt;&lt;br&gt;&lt;img src=&quot;http://pic002.cnblogs.com/images/2012/12069/2012080209370777.jpg&quot; alt=&quot;来自于网络&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://blog.chusaikeji.com/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="http://blog.chusaikeji.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>不求甚解之 UIScrollView</title>
    <link href="http://blog.chusaikeji.com/2015/02/03/%E2%80%9C%E4%B8%8D%E6%B1%82%E7%94%9A%E8%A7%A3%E2%80%9D%E4%B9%8BUIScrollView/"/>
    <id>http://blog.chusaikeji.com/2015/02/03/“不求甚解”之UIScrollView/</id>
    <published>2015-02-02T16:59:00.000Z</published>
    <updated>2018-04-30T15:33:34.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;em&gt;Inheritance: UIView&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;是所有滑动视图的基类, 如UITableView, UICollectionView, UITextView&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;理解UIScrollView-必须理解以下三点&quot;&gt;&lt;a href=&quot;#理解UIScrollView-必须理解以下三点&quot; class=&quot;headerlink&quot; title=&quot;理解UIScrollView, 必须理解以下三点:&quot;&gt;&lt;/a&gt;&lt;strong&gt;理解UIScrollView, 必须理解以下三点:&lt;/strong&gt;&lt;/h2&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;彻底理解&lt;a href=&quot;http://www.jianshu.com/p/b05022b1e488&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;UIView frame, bounds, center
&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对 UIScrollView 的 content 理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;滚动、缩放都是相对于 ScrollView 中的内容的，相当于 ScrollView 是一个窗口，里面的内容被各种缩放、滚动改变位置，我们看到的窗口所在的位置没有发生改变，改变的只是里面的内容。&lt;/li&gt;
&lt;li&gt;UIScrollView 中的缩放是缩放 contentSize&lt;/li&gt;
&lt;li&gt;设置 UIScrollView 中子 View 的 frame 时，是相对于 UIScrollView 的 frame 的，和 contentSize 无关。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对delegate生命周期的理解&lt;/p&gt;
&lt;p&gt; (1) tracking = YES&lt;br&gt; (2) dragging = YES，scrollViewWillBeginDragging:&lt;br&gt; (3) 改变contentOffset，scrollViewDidScroll:&lt;br&gt; (4) 手指离开 UIScrollView, tracking = YES,&lt;br&gt;scrollViewDidEndDragging:willDecelerate:&lt;br&gt; (5) 如果decelerate = YES,发送scrollViewWillBeginDecelerating: 否则直接到第6步&lt;br&gt; (6) decelerating = NO,scrollViewDidEndDecelerating:，所有步骤完成！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;知道了 delegate 在什么时候发送什么消息，我们就可以根据实际需求在特定的方法里写代码了.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;ok-下面我们就来看看UIScrollView的属性和方法&quot;&gt;&lt;a href=&quot;#ok-下面我们就来看看UIScrollView的属性和方法&quot; class=&quot;headerlink&quot; title=&quot;ok. 下面我们就来看看UIScrollView的属性和方法&quot;&gt;&lt;/a&gt;ok. 下面我们就来看看UIScrollView的属性和方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;重要的属性:&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;@property (nonatomic) CGPoint contentOffset;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;内容偏移量，当前显示的内容的顶点相对此控件顶点的x、y距离，默认为CGPointZero (屏幕左上角距离坐标原点的偏移量)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (nonatomic) CGSize contentSize;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;内容大小. 想要出现滚动效果, UIScrollView 的此属性必须大于其Fame属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (nonatomic, assign) id &lt;uiscrollviewdelegate&gt; delegate;&lt;/uiscrollviewdelegate&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;UIScrollView 的代理, 其中定义了视图滚动、缩放、触摸等操作方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;property (nonatomic) UIEdgeInsets contentInset;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;控件四周边距，在scroll周围添加了一段额外的滚动范围, 注意边距不作为其内容的一部分,默认为UIEdgeInsetsZero&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;其他属性&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;@property (nonatomic) BOLL bounces;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是否启用弹簧效果, 启用弹簧效果后拖动到边缘可以看到内容后面的背景, 默认为YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (nonatomic, getter = isPagingEnabled) BOOL pagingEnabled;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是否分页 (按页翻) , 默认为NO&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (nonatomic, getter = isScrollEnabled) BOOL scrollEnabled;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是否启用滚动, 默认为YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (nonatomic) UIScrollViewIndicatorStyle indicatorStyle;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;设置滚动条样式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (nonatomic) BOOL showsHorizontalScrollIndicator;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是否显示横向滚动条, 默认为YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (nonatomic) BOOL showsVerticalScrollIndicator;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是否显示纵向滚动条, 默认为YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (nonatomic) CGFloat minimumZoomScale;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;最小缩放倍数，默认为1.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (nonatomic) CGFloat maximumZoomScale;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;最大缩放倍数(只有maximumZoomScale大于minimumZoomScale才有可能缩放), 默认为1.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property(nonatomic,readonly,getter=isTracking) BOOL tracking;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;（状态）是否正在被追踪，手指按下去并且还没有拖动时是YES，其他情况均为NO&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (nonatomic, readonly, getter=isDragging)     BOOL dragging;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是否正在被拖拽&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (nonatomic, readonly, getter=isDecelerating) BOOL decelerating;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是否正在减速&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (nonatomic, readonly, getter=isZooming) BOOL zooming;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;是否正在缩放&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (nonatomic) BOOL delaysContentTouches;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;布尔类型，当值是 YES 的时候，用户触碰开始，scrollView要延迟一会，看看是否用户有意图滚动。假如滚动了，那么捕捉 touch-down 事件，否则就不捕捉。假如值是NO，当用户触碰， scrollView 会立即触发 touchesShouldBegin:withEvent:inContentView:，默认是 YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (nonatomic) BOOL canCancelContentTouches;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;当值是 YES 的时候，用户触碰后，在一定时间内没有移动，scrollView 发送 tracking events，然后用户移动手指足够长度触发滚动事件，这个时候，scrollView 发送了 touchesCancelled:withEvent: 到 subview，然后 scroView 开始滚动。假如值是 NO，scrollView 发送 tracking events 后，就算用户移动手指，scrollView 也不会滚动。默认是YES&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;常用方法&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;- (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将视图中的内容以动画&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- (void)scrollRectToVisible:(CGRect)rect animated:(BOOL)animated;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;滚动并显示指定区域的内容，第二个参数表示是否启用动画效果&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;代理方法&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;滚动代理方法&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;- (void)scrollViewDidScroll:(UIScrollView *)scrollView;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;(任何偏移量的改变都会调用此方法), 滚动过程中会一直循环执行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;开始拖拽&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;结束拖拽&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;开始减速&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;减速结束, scroll静止&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;缩放代理方法&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;- (void)scrollViewWillBeginZooming:(UIScrollView &lt;em&gt;)scrollView withView:(UIView &lt;/em&gt;)view;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;开始缩放&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- (void)scrollViewDidZoom:(UIScrollView *)scrollView;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;缩放完成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- (UIView &lt;em&gt;)viewForZoomingInScrollView:(UIScrollView &lt;/em&gt;)scrollView;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;返回缩放视图，注意只有实现这个代理方法才能进行缩放，此方法返回需要缩放的视图&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;strong&gt;UIPageControl&lt;/strong&gt; 通常配合UIScrollView使用, 注意以下两点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承UIControl, 说明他和UIButton一样可以添加事件, 但是, 他得事件触发使用的不是UIControlEventsTouchUpInside而是 UIControlEventsValueChanged&lt;/li&gt;
&lt;li&gt;在与UIScrollView配合使用中, 通过偏移量的改变来设置currentPage&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有两个例子没说, 一个是相册, 实现了无限循环(重用), 以及放大缩小等功能, 一个是用UIScrollView实现的简单抽屉效果, 未完待续…&lt;/p&gt;
&lt;p&gt;###Reference&lt;br&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIScrollView_Class/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIScrollView_Class/index.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Inheritance: UIView&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;是所有滑动视图的基类, 如UITableView, UICollectionView, UITextView&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;理解UIScrollView-必须理解以下三点&quot;&gt;&lt;a href=&quot;#理解UIScrollView-必须理解以下三点&quot; class=&quot;headerlink&quot; title=&quot;理解UIScrollView, 必须理解以下三点:&quot;&gt;&lt;/a&gt;&lt;strong&gt;理解UIScrollView, 必须理解以下三点:&lt;/strong&gt;&lt;/h2&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://blog.chusaikeji.com/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="http://blog.chusaikeji.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 开发内存管理之番外篇</title>
    <link href="http://blog.chusaikeji.com/2015/01/28/iOS%E5%BC%80%E5%8F%91%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E7%95%AA%E5%A4%96%E7%AF%87/"/>
    <id>http://blog.chusaikeji.com/2015/01/28/iOS开发内存管理之番外篇/</id>
    <published>2015-01-27T17:26:00.000Z</published>
    <updated>2018-04-30T16:04:13.000Z</updated>
    
    <content type="html">&lt;p&gt;内存管理, 一个恒古的话题, 它不是一个简单的问题. 比如说我们会遇到的一些, 内存莫名的持续增长, 程序莫名的crash, 以及难以发现的内存泄露等等问题, 都是比较让人揪心的. 但是, 只要咱们理解了内存管理的原则, 完全遵照, 其实, 内存管理也是很好解决的.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;内存管理现在大致可以分为两类, 一类是从始至终存在的MRC, 一类是Xcode4.2及以上版本有了的自动管理内存, 也就是ARC. 关于MRC和ARC选择哪一个, @唐巧 的&amp;lt;是否应该使用ARC?&amp;gt;文章已经有了很详细的探讨. &lt;/p&gt;
&lt;p&gt;内存管理, What? Why? How? 这都不是本文讨论的内容, 因为已经有很多非常好的文章来解释这些问题了, 本文将从另外一个角度出发, 教给大家如何调试-解决内存中的问题. 关于What-Why-How本文也会分享一些比较好的文章, 对于不理解内存管理的同学会有很大的帮助.&lt;/p&gt;
&lt;p&gt;一. 开启”僵尸模式” 🍆 🌽 (环境变量)&lt;br&gt;通常情况下，一旦内存中的对象被释放，其只能就此消失。但当“僵尸”方案启动时，该对象只会被标记为“释放”但却仍然被保留在内存当中。如此一来，当我们访问某个僵尸对象时，Xcode会提醒我们该对象虽然能够被访问、但在实际环境中已经不应存在。在这种模式下，我们将能够了解到正常情况下无法获得的实时状态与对象位置。&lt;/p&gt;
&lt;p&gt;Zombie环境变量对于处理EXC_BAD_ACCESS类型崩溃很有效。 当这个zombie工具被启用之后，即使这个对象被释放了，这个对象的内存也不会被清理。这个工具将永远不会释放内存，只是简单标记一下这个内存是不死的(“僵尸”的来历)，你最终将会在某个时候耗尽所有的内存。&lt;/p&gt;
&lt;p&gt;开启”僵尸模式”的步骤:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/193863-0c57b79045a9048d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;依次选择&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/193863-970f6c7161730b0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;勾选上红色区域, 这样就开启了”僵尸模式”.&lt;/p&gt;
&lt;p&gt;二. 静态分析器 (command + shift + B)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;第一种方法, 直接快捷键, 点击左边导航栏中的警告栏&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二种方法, 按下图以此点击&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/193863-29a976a408ea098a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/468&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;ps…这个方法有的时候不是特别靠谱, 看情况的啊, 哈哈~&lt;/p&gt;
&lt;p&gt;三. Instruments 工具&lt;br&gt;Instruments工具可谓是神兵利器了, 功能很强大, 可谓是咱们每个程序员”居家过日子的好帮手”. 以下主要讲解利用Instruments调试内存泄露和循环引用的问题.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开Instruments&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/193863-82173475f2b86e69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/587&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;很简单两步, 然后就会看到它的主界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/193863-a546fb3c195fcd50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;选择leaks –&amp;gt; 点击左上角的大红点 –&amp;gt; 这个时候就开始检测了 ( 这个时候模拟器也会运行起来, 切记一定在模拟器中对你的当前程序进行操作, 以便检测 ) –&amp;gt; 等待检测结束..🐦🐦🐦..&lt;/p&gt;
&lt;p&gt;检测过程中如果出现红色的线, 就证明内存泄露, 如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/193863-6eac128791808805.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果要检测循环引用, 就选择Cycles &amp;amp; Roots, 就可以看到以图形方式显示出来的循环引用了.&lt;/p&gt;
&lt;p&gt;如果要查看内存泄露, 选择Call Tree&lt;/p&gt;
&lt;p&gt;勾选上右边红色方框里的两项, Invert Call Tree 和Hide System Libraries&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/193863-50ffc12b93208d43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这时候内存泄露的具体代码找到了，你只在绿色框里的方法上双击，就会跳转到具体的代码, 一针见血.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;**&lt;/strong&gt; 以上基于Xcode6.1.1 &lt;strong&gt;**&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考的文章:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;《iOS开发进阶》老师 第十章《理解内存管理》&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;《Object-C基础教程》第十章《内存管理》&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;《OC内存管理》 &lt;a href=&quot;http://www.cnblogs.com/wendingding/tag/UI基础/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/wendingding/tag/UI基础/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;《IOS开发系列—Objective-C之内存管理》&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/kenshincui/p/3870325.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/kenshincui/p/3870325.html&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/totogo2010/article/details/8233565&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/totogo2010/article/details/8233565&lt;/a&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;《iOS故障排除指南》 &lt;a href=&quot;http://mobile.51cto.com/iphone-377138.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mobile.51cto.com/iphone-377138.htm&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;内存管理, 一个恒古的话题, 它不是一个简单的问题. 比如说我们会遇到的一些, 内存莫名的持续增长, 程序莫名的crash, 以及难以发现的内存泄露等等问题, 都是比较让人揪心的. 但是, 只要咱们理解了内存管理的原则, 完全遵照, 其实, 内存管理也是很好解决的.&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://blog.chusaikeji.com/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="http://blog.chusaikeji.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>如何利用查头文件学习 iOS 开发</title>
    <link href="http://blog.chusaikeji.com/2015/01/26/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%9F%A5%E5%A4%B4%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%20iOS%20%E5%BC%80%E5%8F%91/"/>
    <id>http://blog.chusaikeji.com/2015/01/26/如何利用查头文件学习 iOS 开发/</id>
    <published>2015-01-26T15:07:00.000Z</published>
    <updated>2018-04-30T15:53:44.000Z</updated>
    
    <content type="html">&lt;p&gt;今天我们要总结的是利用Xcode, 查找头文件, 进行快速有效的学习方法, 总结为一个字—-“查”.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;先上神兵利器—- “command + F”, 搜索快捷键可以帮助我们快速查找所需要的东西. 不知道的同学可以随便找个地方试试…&lt;/p&gt;
&lt;p&gt;进入今天的正题, 看过头文件的同学都应该知道, 少的有三十多行, 多的有上千行, 各种属性, 各种方法, 琳琅满目, “人山人海”啊, 单靠记忆恐怕是记不完的, 所以查很好的解决了我们的问题, 那么如何来查呢?&lt;/p&gt;
&lt;p&gt;举个例子, 如果我们遇到没见过的控件, 不明白的方法, 怎么办, 查, 怎么查, 在xcode中, 按住command, 点击控件名或者方法(只要是能点进去的都可以), 然后就会进入头文件, 此时就可以按照”三步走战略”来快速查看头文件了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/193863-d9224943fc867409.png?imageView2/2/w/1240/q/100&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;第一步: 看它继承于谁(继承关系很重要的)&lt;/p&gt;
&lt;p&gt;第二步: 看它有没有自己的初始化方法, 如果没有就用父类的&lt;/p&gt;
&lt;p&gt;第三步: 看它是否有代理, 如果有, 看哪些方法是必须实现的&lt;/p&gt;
&lt;p&gt;以UIActionSheet为例:&lt;/p&gt;
&lt;p&gt;在Xcode中输入UIActionSheet, 按住command点击, 进入到头文件, 执行 “三步走战略” :&lt;/p&gt;
&lt;p&gt;第一步: 继承于UIView, 立马想到UIView的所有东西它都可以用.(OC三大特征中的继承 , 必须要掌握的 )&lt;/p&gt;
&lt;p&gt;第二步: 继续往下看, 发现它有自己的初始化方法, 比较长的一个初始化方法. (如果没有找到它自己的初始化方法, 咱们就用它父类的初始化方法) 有的时候头文件里的内容特别多, 很难找到初始化方法, 这时, 就需要我们的神兵利器 “command + F “了, 按下后, 在弹出来的搜索框里输入”init”, 回车, 就会看到, 快速跳转到包含”init”的方法了. 以此类推, 对于很多方法, 没必要死记硬背, 只要记住它里面的关键词, 如果需要调用此方法, 就进入对应的头文件, 利用我们的神兵利器, 快速查找.&lt;/p&gt;
&lt;p&gt;第三步: 继续往下看, 发现了什么, id&lt;uiactionsheetdelegate&gt; delegate 说明有代理方法, 怎么办, 继续 按住command + 点击UIActionSheetDelegate点进去进去看, 发现是@optional, 说明不是必须要实现的方法, 咱们可以暂时不用签订协议.&lt;/uiactionsheetdelegate&gt;&lt;/p&gt;
&lt;p&gt;ok. 现在三步走战略完了, 回到咱们的viewController里, 建一个UIActionSheet, 既然它继承于UIView, 无非也就是创建一view那几步 (继承关系)&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// UIActionSheet的初始化方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIActionSheet *actionSheet = [[UIActionSheet alloc] &lt;span class=&quot;string&quot;&gt;initWithTitle:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;分享&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;delegate:&lt;/span&gt;self &lt;span class=&quot;string&quot;&gt;cancelButtonTitle:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;取消&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;destructiveButtonTitle:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;微博分享&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;otherButtonTitles:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;微信分享&quot;&lt;/span&gt;, nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 不需要设置frame和backgroundColor&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 添加到view上&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self.view &lt;span class=&quot;string&quot;&gt;addSubview:&lt;/span&gt;actionSheet];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果是MRC下需要release&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;好了, 运行一下, 发现了什么, 对, 什么都没出来, 怎么办, 继续点进去看, 肯定是有什么属性或者方法是需要咱们必须要写上的, 一行一行的找, 找到了什么, 好几条跟show有关的方法, 柳暗花明又一村啊.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/193863-6e312800a435f887.png?imageView2/2/w/1240/q/100&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;发现了吧, 要让咱们的actionSheet显示出来还需要加一条方法, 咱们就选择最后一个方法&lt;/p&gt;
&lt;p&gt;// 必须要写的方法, 否则不会显示出来&lt;/p&gt;
&lt;p&gt;[actionSheet showInView:self.view];&lt;/p&gt;
&lt;p&gt;运行一下, 一个简单的UIActionSheet就出来了, 当然了, UIActionSheet还有很多的属性和方法, 咱们都可以通过”查”来一一学习.&lt;/p&gt;
&lt;p&gt;最后, 不论是查看头文件还是Xcode帮助文档, 都应该把握”三步走战略”, 以此为主线, 展开调研.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们要总结的是利用Xcode, 查找头文件, 进行快速有效的学习方法, 总结为一个字—-“查”.&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://blog.chusaikeji.com/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="http://blog.chusaikeji.com/tags/iOS/"/>
    
  </entry>
  
</feed>
